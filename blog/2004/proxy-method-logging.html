<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Proxy Method Logging</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Christopher J. Stehno">
    <meta name="keywords" content="java,groovy,blog">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/asciidoctor.css" rel="stylesheet">
    <link href="/css/base.css" rel="stylesheet">
    <link href="/css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="shortcut icon" href="/favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
   
	
		<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">CoffeaElectronica.com</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="/index.html">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="/archive.html">Archive</a></li>
            
             <li role="presentation" class="dropdown">
	      <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-expanded="false">
		Tags <span class="caret"></span>
	      </a>
	      <ul class="dropdown-menu" role="menu">
		
		  <li><a href="/tags/ant.html">ant</a></li>
		
		  <li><a href="/tags/blog.html">blog</a></li>
		
		  <li><a href="/tags/gradle.html">gradle</a></li>
		
		  <li><a href="/tags/groovy.html">groovy</a></li>
		
		  <li><a href="/tags/java.html">java</a></li>
		
		  <li><a href="/tags/javascript.html">javascript</a></li>
		
		  <li><a href="/tags/maven.html">maven</a></li>
		
		  <li><a href="/tags/python.html">python</a></li>
		
		  <li><a href="/tags/spring.html">spring</a></li>
		
		  <li><a href="/tags/testing.html">testing</a></li>
		
		
	      </ul>
	    </li>
            
            <li><a href="/feed.xml">Subscribe</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
    

	
	<div class="page-header">
		<h1>Proxy Method Logging</h1>
	</div>

	<p><em>11 February 2004</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/java.html'>java</a></p>

	<p><p>Here's an interesting spin on logging. Say you have a service of some kind that loads in other classes dynamically such as modules or plug-ins and you want to provide a seamless debugging mode no matter what kind of logging the module developer has done. You can use a <code>java.lang.reflect.Proxy</code> to do your method call logging. Basically, you build a wrapper around your module that does the logging for any module.</p><p>First off, you need an interface to do this, any interface that your modules implement will work.</p>
<pre><code class="java">public interface SomeInterface {

    public void doSomethingA(String p1, int p2);

    public String[] doSomethingB(Map map);
}
</code></pre><p>Second, you will need an implementation of that interface, your module or plug-in class. This is the actual object doing the work whose method calls will be logged.</p>
<pre><code class="java">public class SomeImplnterfaceImpl implements SomeInterface {

    public SomeImplnterfaceImpl(){}

    public void doSomethingA(String p1, int p2){
        System.out.println(&quot;doSomethingA with (&quot; + p1 + &quot; and &quot; + p2 + &quot;)&quot;);
    }

    public String[] doSomethingB(Map map){
        System.out.println(&quot;doSomethingB with a Map: &quot; + map);
        return( (String[])map.values().toArray(new String[0]) );
    }
}
</code></pre><p>Both of the above items you should already have in your system. If not, in most cases, they can be easily added. Now we get into the good stuff. The Proxy class is an interesting little creature. It allows you to give it an array of interfaces that it is to "implement" by passing method calls to an instance of the <code>InvocationHandler</code> interface, which determines how the method calls are to be processed. Our proxy will simply log the method call and pass it along to the real implementation. We'll make a factory class to create our logging proxy. It will have one method with two arguments. The first is the interface that is to be logged, <code>SomeInterface</code> in our example, and the second is the implementation of that interface, <code>SomeInterfaceImpl</code> for our example.</p>
<pre><code class="java">public final class LoggingProxyFactory {

    private LoggingProxyFactory(){}

    public static final Object create(Class interfc,Object impl) throws Exception {
        LoggingHandler handler = new LoggingHandler(impl);
        return(
            Proxy.newProxyInstance(
                impl.getClass().getClassLoader(),
                new Class[]{interfc},
                handler
            )
        );
    }
}
</code></pre><p>You see that creating a proxy is pretty simple. You create a proxy instance using your interfaces, your class loader and your invocation handler. The invocation handler is where the action happens. Our <code>InvocationHandler</code> implementation is going to be a static inner class of the <code>LoggingProxyFactory</code> class. What it needs to do is logs the method calls as they come in and then pass along the call to the real implementation. Here is the code for the inner class.</p>
<pre><code class="java">private static final class LoggingHandler implements InvocationHandler {

    private Log log;
    private Object impl;

    private LoggingHandler(Object impl){
        this.impl = impl;
        this.log = LogFactory.getLog(impl.getClass());
    }

    public Object invoke(Object obj,Method method,Object[] params) throws Throwable {
        if(log.isInfoEnabled()) log.info(&quot;Entering: &quot; + method.getName();

        if(log.isDebugEnabled()){
            for(int p=0; p&amp;amp;tl;params.length;p++){
                log.debug(method.getName() + &quot; Param[&quot; + p + &quot;]: &quot; + params[p].toString());
            }
        }

        Object ret = null;

        try {ret = method.invoke(impl, params);}
        catch(Exception ex){
            if(log.isErrorEnabled()){
                log.error(method.getName() + &quot; Exception: &quot; + ex.getMessage(), ex);
            }
            throw ex;
        }

        if(log.isDebugEnabled()) log.debug(method.getName() + &quot; Returned: &quot; + ret);

        if(log.isInfoEnabled()) log.info(&quot;Leaving&quot;);

        return(ret);
    }
}
</code></pre><p>I am using the <a href="http://commons.apache.org/logging">Jakarta Logging API</a> for the logging in this case; however, you could use any logging API or simple standard out statements as you see fit. The main thing to notice in the code above is the invocation of the method on the implementation object.</p></p>
<pre><code class="java">ret = method.invoke(impl, params);
</code></pre><p>It is this line that passes on the method call to the real implementation. The rest of the method is logging of the entering and leaving, parameters and return value. Exceptions are also logged. To test out the proxy and see it in action, you can run the following tester app:</p>
<pre><code class="java">public class Tester {
    public static void main(String[] args){
        try {
            Object obj = LoggingProxyFactory.create(
                SomeInterface.class,
                new SomeImplnterfaceImpl()
            );
            SomeInterface siObj = (SomeInterface)obj;
            siObj.doSomethingA(&quot;Hello&quot;,31);

            Map map = new HashMap();
            map.put(&quot;a&quot;, &quot;Some data 1&quot;);
            map.put(&quot;b&quot;, &quot;Some data 2&quot;);
            map.put(&quot;c&quot;, &quot;Some data 3&quot;);
            map.put(&quot;d&quot;, &quot;Some data 4&quot;);
            siObj.doSomethingB(map);
        } catch(Exception ex){
            ex.printStackTrace();
        }
    }
}
</code></pre><p>Which yields the method call results and their logging information. This was an interesting idea I have tossed around for a while now. It does work, though it has not been rigorously tested. If nothing else, it is a description of how to use the proxy class.</p></p>

	<hr />
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2015 <a href="https://plus.google.com/+ChristopherStehno">Christopher J. Stehno</a> | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.3.2</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../js/jquery-1.11.1.min.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
    <script src="../../js/prettify.js"></script>
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-27165855-1', 'auto');
      ga('send', 'pageview');
    </script>
    
  </body>
</html>