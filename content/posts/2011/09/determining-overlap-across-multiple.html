
<html><head>
<title>Determining Overlap Across Multiple Variables</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2011-09-05T11:31:00.000-05:00" />
</head><body><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-4p-FCTX7ypM/TmTqDSe0TCI/AAAAAAAABxU/_NyoOE-UPe0/s1600/simple_venn.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="200" src="http://4.bp.blogspot.com/-4p-FCTX7ypM/TmTqDSe0TCI/AAAAAAAABxU/_NyoOE-UPe0/s200/simple_venn.png" width="195" /></a></div>I have run into two cases now where I have needed to validate that no overlap exists for data across three axes of comparison, each with potentially large value-spaces containing single values and/or ranges of values. An example of such a comparison could be something like a filter rule used to find People based on demographic data. <br /><br /><a name='more'></a>Say we have a search rule to find males between 15 and 25 years old who weigh 200 to 300 pounds. You could have something like:<br /><br /><b>People A</b><br />Ages: 15-25<br />Gender: M<br />Weight: 200-300<br /><br />Now consider the case when you have other search rules in the same search and that for the sake of efficiency we want to find overlapping rules and merge them into one (we will only consider the overlap determination here). With two other rules:<br /><br /><b>People B</b><br />Ages: 13-20<br />Gender: M<br />Weight: 250-400<br /><br /><b>People C</b><br />Ages: 8-10<br />Gender: M<br />Weight: 200-300<br /><br />It's not hard to look at the rules and determine which ones overlap. "People A" overlaps with "People B", while "People C" does not overlap with either of the other two. Programmatically this can be a difficult comparison to do correctly and efficiently. Also, as your number of comparison axes increases, so does the complexity of determining overlap for any given pair of objects.<br /><br />What is needed is a simple means of determining the overlap of two objects and the best way I have found to do that is to break each object down into its overlap-comparison components, each of which I will call a "Lobe" from here on out. I chose the term lobe because it is defined as:<br /><blockquote>"any rounded projection forming part of a larger structure"</blockquote>Also, terms like element and node are used far too much already in programming.<br /><br />When you break each object down into it's lobes, you will have one lobe for Gender, one for Ages, and one for weights. Now you can build your overlap determination based on whether or not each lobe overlaps with its corresponding lobe on the other object. If all of the lobes overlap those of the other object, then the two objects are considered overlapping, otherwise they are not. This allows for a fail-fast comparison since if the comparison of any given lobe fails, you cannot have an overlapping object and no further comparison is necessary.<br /><br />Programmatically a lobe can be defined by interface as:<br /><br /><pre class="brush:groovy">interface Lobe {<br />    boolean overlaps( Lobe other )<br />}<br /></pre><br />Each lobe implementation defines what it means to overlap another Lobe of the same type. Using Groovy and some generic logic we can easily come up with a <a href="http://github.com/cjstehno/overlap/blob/master/src/main/groovy/com/stehno/overlap/ComparableLobe.groovy">ComparableLobe</a> which is based on single values and ranges of Comparable objects such as numbers, strings and ranges. This allows us to do things like:<br /><pre class="brush:groovy">new ComparableLobe( 10..20, 50, 75 )<br />new ComparableLobe( 'a', 'h'..'j', 'm' )<br /><br />lobeA.overlaps( lobeB )<br /></pre>which can make the overlap determination very flexible.<br /><blockquote><b>Note:</b> All of the source code from this article is available in my <a href="http://github.com/">GitHub</a> repo called <a href="http://github.com/cjstehno/overlap">Overlap</a>.</blockquote>Now we can create Lobes for each of the overlap-comparable parts of our People, using "People A" as an example:<br /><br /><pre class="brush:groovy">def genderLobe = new ComparableLobe( 'M' )<br />def agesLobe = new ComparableLobe( 15..25 )<br />def weightsLobe = new ComparableLobe( 200..300 )<br /></pre><br />The next thing we need is a way of comparing these lobes in a simple and repeatable manner and that's where the <a href="http://github.com/cjstehno/overlap/blob/master/src/main/groovy/com/stehno/overlap/Overlappable.groovy">Overlappable</a> interface comes in:<br /><br /><pre class="brush:groovy">interface Overlappable {<br />    boolean overlaps ( Overlappable other )<br />}<br /></pre><br />The Overlappable interface defines an object that can be compared for overlap. The required method is basically the same as that of the Lobe; however, this interface is for the parent object itself. By providing an abstract implementation of this interface we have a nice clean way of providing overlap detection functionality for an object type. The <a href="http://github.com/cjstehno/overlap/blob/master/src/main/groovy/com/stehno/overlap/AbstractOverlappable.groovy">AbstractOverlappable</a> provides an implementation of the overlaps() method using the OverlapBuilder, which we will talk about in a minute. What the abstract class also provides is a simple way of emitting the Lobes for the given object in a simple manner, as an array. You can use this with our example above to create a simple Overlappable Person object:<br /><br /><pre class="brush:groovy">class People extends AbstractOverlappable {<br />    String gender<br />    IntRange ages<br />    IntRange weights<br />	<br />    @Override<br />    Lobe[] lobes() {<br />        [<br />            new ComparableLobe(gender),&nbsp;<br />            new ComparableLobe(ages),&nbsp;<br />            new ComparableLobe(weights)&nbsp;<br />        ]<br />    }<br />}<br /></pre><br />The overlaps() method uses the provided Lobes to popualte an <a href="http://github.com/cjstehno/overlap/blob/master/src/main/groovy/com/stehno/overlap/OverlapBuilder.groovy">OverlapBuilder</a>, which is basically a helper class for performing the actual Lobe-to-Lobe comparison of a given set of Lobes. The OverlapBuilder is inspired by the builder in the Apache Commons - Lang API, such as EqualsBuilder and HashCodeBuilder. You create an instance and append your Lobes to it, then execute the overlap() method to perform the comparison.<br /><br /><pre class="brush:groovy">new OverlapBuilder()<br />    .appendLobe(new ComparableLobe(1..10), new ComparableLobe(5..15))<br />    .overlap()<br /></pre><br />It also provides an append method for simple comparable cases:<br /><br /><pre class="brush:groovy">overlapBuilder.appendComparable( 20..25, 15..30 )<br /></pre><br />which just wraps each value in a ComparableLobe.&nbsp;Now, given a list of People objects, you can determine if any of them overlap any of the others simply by iterating over the list and comparing each element with the others:<br /><br /><pre class="brush:groovy">def list = [<br />    new Person( gender:'M', ages:15..25, weights:200..300 ),<br />    new Person( gender:'M', ages:13..20, weights:250..400 ),<br />    new Person( gender:'M', ages:8..10, weights:200..300 )<br />]<br /><br />list[0..-2].eachWithIndex { self, idx-&gt;<br />    list[(idx+1)..(-1)].each { other-&gt;<br />        if( self.overlaps( other ) ){<br />            println "$self overlaps $other"<br />        }<br />    }<br />}<br /></pre><br />As a final little bonus feature, I have added a ComparableLobe.ANY object which denotes a Lobe that will always be considered to overlap, no matter what the other value is.<br /><br />This kind of multi-variable overlap-checking scenario may not come up all that often, but when it does, it can give you a lot of grief, especially if the fields being compared are numerous and complex. I have had to create a couple additional Lobe implementations but am also using the ComparableLobe quite a bit. This library has been a real time-saver. And, once broken down into component parts, the overlap determination becomes simple to implement and test, which makes it much more stable over time.<br /><br /></body></html>
