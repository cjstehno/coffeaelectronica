<html>
<head>
    <title>Spring Deserialized ObjectFactory</title>
    <meta name="grackle.layout" content="post"/>
    <meta name="grackle.date-published" content="2008-04-28T11:27:00.000-05:00"/>
</head>
<body>I recently had the idea that it would be interesting to have a <a href="http://springframework.org/">Spring</a>
factory bean that would load a serialized object as its object contribution. I have no idea at this point what it would
be useful for; it was just something that popped into my head. My example below describes a license key system that is
not based on anything real so please don't expect this to be a good license key implementation... it's just an example
of the deserialized bean factory idea.<br/><a name='more'></a>First, we need something to serialize. As I mentioned
earlier, I am doing a quick and dirty license key system so the key itself would be a good candidate for the
serializable object. Let's create a license key object as follows: <br/><br/>
<pre class="brush:java">public class LicenseKey implements Serializable {<br/><br/>    private static final long serialVersionUID = -3151020875557193150L;<br/>    <br/>    private long created;<br/>    private String key;<br/>    <br/>    public LicenseKey(){<br/>        super();<br/>    }<br/>    <br/>    public LicenseKey(final long created, final String key){<br/>        this.created = created;<br/>        this.key = key;<br/>    }<br/>    <br/>    public long getCreated() {return created;}<br/>    <br/>    public String getKey() {return key;}<br/>}<br/></pre>
<br/>Notice that it implements the Serializable interface and has a couple of fields that we can later use to prove that
the bean is deserialized and loaded properly. Next, we need to serialize this object into a license key file, which will
later be used by the factory bean. I threw together a simple serializer which also utilizes the <a
        href="http://commons.apache.org/lang">Jakarta Commons - Lang API</a>: <br/><br/>
<pre class="brush:java">public class Serializer {<br/>    <br/>    public static void main(final String[] args) throws FileNotFoundException {<br/>        final LicenseKey key = new LicenseKey(System.currentTimeMillis(),UUID.randomUUID().toString());<br/>        SerializationUtils.serialize(key, new FileOutputStream(new File("license.key")));<br/>        System.out.println("Done");<br/>    }<br/>}<br/></pre>
<br/>This just creates a simple key object and serializes it to the current directory as the "license.key" file, which
we will use later. Now that we have a serialized license key, we need a Spring factory bean to load and instantiate the
<tt>LicenseKey</tt> object it represents. The <tt>DeserializedObjectFactory</tt> is simply an extension of Spring's <tt>AbstractFactoryBean</tt>
that deserializes the given file resource and verifies that it is an instance of the specified class. <br/><br/>
<pre class="brush:java">public class DeserializedObjectFactory extends AbstractFactoryBean {<br/>    	<br/>    private final Class&lt;? extends Serializable&gt; objectType;<br/>    private final Resource resource;<br/>        <br/>    public DeserializedObjectFactory(final Class&lt;? extends Serializable&gt; objectType, final Resource resource){<br/>        this.objectType = objectType;<br/>        this.resource = resource;<br/>    }<br/>    <br/>    @Override<br/>    protected Object createInstance() throws Exception {<br/>        final Object obj = SerializationUtils.deserialize(resource.getInputStream());<br/>        Assert.isInstanceOf(objectType, obj, "Serialized object must be of type: " + objectType);<br/>        return obj;<br/>    }<br/>    <br/>    @Override<br/>    public Class&lt;? extends Serializable&gt; getObjectType() {<br/>        return objectType;<br/>    }<br/>}<br/></pre>
<br/>The generic parameter restrictions and the instance checking add a bit of safety to the factory such that it keeps
you from loading something completely unexpected. In order to make use of these beans, we will need some client class to
actually use the deserialized object, and that's where the <tt>LicenseVerifier</tt> class comes in. The license verifier
is a simple class that takes a license key as a parameter and has a verification method that will be used to ensure that
a proper license key is configured. <br/><br/>
<pre class="brush:java">public class LicenseVerifier {<br/>    <br/>    private static final Log log = LogFactory.getLog(LicenseVerifier.class);<br/>    private LicenseKey licenseKey;<br/>    <br/>    public void setLicenseKey(final LicenseKey licenseKey) {<br/>        this.licenseKey = licenseKey;<br/>    }<br/>    <br/>    public void verify(){<br/>        // do some license verification<br/>        Assert.notNull(licenseKey, "No license key exists!");<br/>        Assert.notNull(licenseKey.getKey(), "Invalid key!");<br/>  <br/>        log.info("License verified: created: " + licenseKey.getCreated() + ", key: " + licenseKey.getKey());<br/>    }<br/>}<br/></pre>
<br/>Finally we need the glue that brings all of this together, the Spring context file: <br/><br/>
<pre class="brush:xml">&lt;bean id="license.key" class="spring.DeserializedObjectFactory"&gt;<br/>    &lt;constructor-arg value="spring.LicenseKey" /&gt;<br/>    &lt;constructor-arg value="license.key" /&gt;<br/>&lt;/bean&gt;<br/>    <br/>&lt;bean id="license.verifier" class="spring.LicenseVerifier" init-method="verify"&gt;<br/>    &lt;property name="licenseKey" ref="license.key" /&gt;<br/>&lt;/bean&gt;<br/></pre>
<br/>Notice the <tt>init-method</tt> on the license verifier bean; it is used to ensure that the license is verified
when the context starts up. With that, you can startup the context and watch the magic happen: <br/><br/>
<pre class="brush:java">new FileSystemXmlApplicationContext("context.xml")</pre>
<br/>You should get some miscellaneous logging and then the license verification log entry with populated data, which
will look something like this (of course your values will be different): <br/><br/>
<pre class="brush:text">INFO: License verified: created: 1209321756486, key: 5ed38eba-799a-4b8c-9bfc-dd539c20bafe</pre>
<br/>That's all there is to it. Like I said, I am not sure what it would really be useful for but it was an interesting
little experiment. I found it interesting because it would be simple to swap out serialized object files as needed to
provide different instances, in this case different licenses. This concept could also be used with other "serialization"
methods, such as XML or some other custom serializer. I chose the default Java serialization just for ease of
demonstration.<br/><br/>Again I must mention that this is NOT intended to be a legitimate licensing strategy and it
contains MANY security holes. If you use it, you are on your own and I take no responsibility for the results.
</body>
</html>
