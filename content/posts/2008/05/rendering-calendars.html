
<html><head>
<title>Rendering Calendars</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2008-05-31T10:21:00.000-05:00" />
</head><body><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-KZmHznvYzjI/ToiFqbFTRCI/AAAAAAAAB-o/diz_3swy2yg/s1600/calendar_image.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="200" src="http://2.bp.blogspot.com/-KZmHznvYzjI/ToiFqbFTRCI/AAAAAAAAB-o/diz_3swy2yg/s200/calendar_image.png" width="200" /></a></div>I am poking around with an idea I had to generate desktop background images with little calendars embedded in them and I realized that there is no really easy method of rendering your standard square text calendar display. I decided to play around with it a bit. The basic algorithm to generate the weeks and their associated days is nothing too complicated:<br /><ol><li>Figure out what day of the week the first day of the month falls on.</li><li>Subtract from that the value for Sunday (the start of the week), which assumes that the day of the week field values are sequential (which they are).</li><li>Iterate through the day of the month keeping track of the week breaks.</li></ol><br /><a name='more'></a>I created a factory class, <tt>MonthFactory</tt> and a couple helper model objects, <tt>Month</tt> and <tt>Week</tt> to make things a little easier. <tt>Month</tt> and <tt>Week</tt> are pretty simple data objects used to store the month and week data in a meaningful structure.<br /><pre class="brush:java">public class Week {<br />    private final String[] days = new String[7];<br />    private int index = 0;<br /><br />    public Iterable&lt;string&gt; days(){<br />        return Arrays.asList(days);<br />    }<br /><br />    boolean append(final String day){<br />        days[index++] = day;<br />        return index != 7;<br />    }<br /><br />    void padding(final int size){<br />        index = size;<br />    }<br /><br />    @Override<br />    public String toString(){<br />        return Arrays.toString(days);<br />    }<br />}</pre>I used strings to store the day values, you could also use ints.  <br /><pre class="brush:java">public class Month {<br />    private final List&lt;week&gt; weeks = new LinkedList&lt;week&gt;();<br />    private final String name;<br />    private final int year;<br />    <br />    Month(final String name, final int year){<br />        this.name = name;<br />        this.year = year;<br />    }<br />    <br />    public Iterable&lt;week&gt; weeks(){<br />        return weeks;<br />    }<br />    <br />    public String getName(){return name;}<br />   <br />    public int getYear(){return year;}<br />    <br />    void append(final Week week){<br />        weeks.add(week);<br />    }<br />    <br />    @Override<br />    public String toString() {<br />        return "{" + name + " " + year + ": weeks=" + weeks.toString();<br />    }<br />}</pre>Both of these classes have very limited public interfaces. They exist in the same package as the <tt>MonthFactory</tt> class which is used to build them. External client classes should really only be accessing them as read-only. The <tt>MonthFactory</tt> is also pretty simple, but it does contain the algorithm I mentioned earlier so it is the meat of the whole example:  <br /><pre class="brush:java">public class MonthFactory {<br />    <br />    public static Month create(final int calendarMonth, final int year) throws Exception {<br />        validate(calendarMonth,year);<br />    <br />        final Calendar cal = Calendar.getInstance();<br />        cal.set(Calendar.MONTH, calendarMonth);<br />        cal.set(Calendar.DAY_OF_MONTH, 1);<br />        cal.set(Calendar.YEAR, year);<br />  <br />        final int daysInMonth = cal.getActualMaximum(Calendar.DAY_OF_MONTH);<br />        final String name = cal.getDisplayName(Calendar.MONTH,Calendar.LONG,Locale.getDefault());<br />        final Month month = new Month(name,year);<br />   <br />        Week week = new Week();<br />        week.padding(cal.get(Calendar.DAY_OF_WEEK) - Calendar.SUNDAY);<br />    <br />        for(int i=1; i&lt;=daysInMonth; i++){<br />            if(!week.append(String.valueOf(i))){<br />                month.append(week);<br />                week = new Week();<br />            }<br />        }<br />        month.append(week);<br />  <br />        return month;<br />    }<br />    <br />    private static void validate(final int calMon,final int year){<br />        if(calMon &lt; Calendar.JANUARY || calMon &gt; Calendar.DECEMBER){<br />            throw new IllegalArgumentException("Invalid Calendar Month specified: " + calMon);<br />        }<br />        if(year &lt; 0){<br />            throw new IllegalArgumentException("Year must be non-negative: " + year);<br />        }<br />    }<br />}</pre>I even threw in some simple input validation for free. Now for a simple use of this code I created a <tt>TextCalendar</tt> class that simply generates a text calendar which will look right if it's rendered in a fixed-width font.  <br /><pre class="brush:java">public class TextCalendar {<br />    <br />    public static void main(final String[] args) throws Exception {<br />        final Month month = MonthFactory.create(Calendar.JULY,2008);<br />            <br />        final StringBuilder str = new StringBuilder();<br />    <br />        final String header = month.getName() + " " + String.valueOf(month.getYear());<br />        str.append(padding(10 - header.length()/2,' ')).append(header).append('\n');<br />    <br />        for(final Week week : month.weeks()){<br />            for(final String day : week.days()){<br />                if(day == null){<br />                    str.append("  ");<br />                } else {<br />                    str.append(day.length() == 2 ? day : " " + day);<br />                }<br />                str.append(" ");<br />            }<br />            str.append('\n');<br />        }<br />   <br />        System.out.println(str.toString());<br /> <br />    }<br />  <br />    private static String padding(final int size, final char val){<br />        final char[] pad = new char[size];<br />        Arrays.fill(pad, val);<br />        return new String(pad);<br />    }<br />}</pre>This just serves to show how easy this makes calendar rendering. Upon running this little application you will get the following nicely formatted calendar (I even centered the header):<br /><pre>          July 2008<br />           1  2  3  4  5 <br />     6  7  8  9 10 11 12 <br />    13 14 15 16 17 18 19 <br />    20 21 22 23 24 25 26 <br />    27 28 29 30 31       <br /></pre>If there are existing libraries to do this, I would love to hear about them. I could not find anything. Obviously this example corresponds to the standard US display of the Gregorian Calendar. I would think that it could be made to work for other calendars as well, but I have never actually seen any other calendars displayed... I guess I need to travel the world more.  I provide these as examples only; there may be better ways to accomplish this and there are definitely code modifications and improvements that could be made. I am not currently using this code anywhere... it was just an experiment. Use at your own risk. :-)</body></html>
