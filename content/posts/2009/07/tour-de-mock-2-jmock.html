<html>
<head>
    <title>Tour de Mock 2: JMock</title>
    <meta name="grackle.layout" content="post"/>
    <meta name="grackle.date-published" content="2009-07-21T11:08:00.000-05:00"/>
</head>
<body>The next mocking API to consider is one that I have used for years, <a href="http://jmock.org/">JMock</a>,
specifically JMock 2 (for a discussion of JMock 1 usage, please see my older posting "<a
        href="http://www.coffeaelectronica.com/2006/09/are-you-mocking-me.html">Are You Mocking Me?</a>"). <br/><a
        name='more'></a>JMock uses a more Domain Specific Language approach to mocking that is very flexible and very
expressive, though it can be a bit daunting to someone who's never used it before. One of the first things you will
notice about the test in the <tt>EmailListServlet_JMockTest</tt> is that it uses the <tt>@RunWith</tt> annotation
provided by <a href="http://junit.org/">JUnit</a>. This annotation tells JUnit to use a test runner other than the
default. In this case, JMock provides a test runner to simplify use of its Mockery construct (you will see it as one of
the instance variables). The Mockery is used to create and manage the mocking system. Using the JMock runner allows
JUnit to handle the mockery verification step after each test so that you don't have to do it yourself. You may also
notice that I have defined a constructor for this test to set the "imposteriser" (mock creator) used. Since we have both
interfaces and classes to mock, the "legacy" imposteriser must be used. <br/><br/>
<pre class="brush:java">@RunWith(JMock.class)<br/>public class EmailListServlet_JMockTest {<br/>    private Mockery mockery = new JUnit4Mockery();<br/><br/>    public EmailListServlet_JMockTest(){<br/>        mockery.setImposteriser(ClassImposteriser.INSTANCE);<br/>    }<br/>}</pre>
<br/>The <tt>@Before</tt> method in this example is a bit more complex than that of the Spring mocking example, since
you have to do a bit more of the binding work yourself: <br/><br/>
<pre class="brush:java">@Before<br/>public void before() throws ServletException {<br/>    this.emailListService = mockery.mock(EmailListService.class);<br/><br/>    final ServletConfig servletConfig = mockery.mock(ServletConfig.class);<br/>    mockery.checking(new Expectations(){<br/>        {<br/>            final ServletContext servletContext = mockery.mock(ServletContext.class);<br/>            one(servletConfig).getServletContext(); will(returnValue(servletContext));<br/>            one(servletContext).getAttribute(EmailListService.KEY); will(returnValue(emailListService));<br/>        }<br/>    });<br/><br/>    this.servlet = new EmailListServlet();<br/>    servlet.init(servletConfig);<br/><br/>    this.request = mockery.mock(HttpServletRequest.class);<br/>    this.response = mockery.mock(HttpServletResponse.class);<br/>}</pre>
<br/>The <tt>mockery.checking()</tt> method is one of the most used constructs in mocking with JMock. It allows you to
provide your test expectations. In this case you can see that we are expecting one call to <tt>servletConfig.getServletContext()</tt>,
which will return the mock <tt>ServletContext</tt> we have created. We are also expecting one call to the <tt>getAttribute()</tt>
method of the mocked servlet context with the email service key, which will return our mocked <tt>EmailListService</tt>
(note, in this test we don't actually implement the service interface, we just mock it like everything else). The "no
list name" exception-checking test is also a bit more complicated than the previous example: <br/><br/>
<pre class="brush:java">@Test(expected=IOException.class)<br/>public void doGet_without_list() throws Exception {<br/>    mockery.checking(new Expectations(){<br/>        {<br/>            one(request).getParameter("listName"); will(returnValue(null));<br/>            one(emailListService).getListByName(null); will(throwException(new IOException()));<br/>        }<br/>    });<br/><br/>    servlet.doGet(request, response);<br/>}</pre>
<br/>We actually need to code the behavior for a null return of the "listName" parameter and cause the exception to be
thrown by the service. The other test, the "with list name" test is the more interesting of the two now: <br/><br/>
<pre class="brush:java">@Test<br/>public void doGet_with_list() throws Exception {<br/>    final PrintWriter writer = mockery.mock(PrintWriter.class);<br/>    final Sequence printSequence = mockery.sequence("printSequence");<br/>    mockery.checking(new Expectations(){<br/>        {<br/>            one(request).getParameter("listName"); will(returnValue("foolist"));<br/><br/>            final List&lt;String&gt; list = Arrays.asList("larry@stooge.com","moe@stooge.com","curley@stooge.com");<br/>            one(emailListService).getListByName("foolist"); will(returnValue( list ));<br/><br/>            one(response).getWriter(); will(returnValue(writer));<br/><br/>            one(writer).println("larry@stooge.com"); inSequence(printSequence);<br/>            one(writer).println("moe@stooge.com"); inSequence(printSequence);<br/>            one(writer).println("curley@stooge.com"); inSequence(printSequence);<br/>            one(writer).close(); inSequence(printSequence);<br/>        }<br/>    });<br/><br/>    servlet.doGet(request, response);<br/>}</pre>
<br/>You will see again, that the basic call behavior is specified as is the service return value, but here, also we
actually see some of the benefit of all this extra code. Notice the sequence behavior. You can define a sequence of
calls which must be performed in the order specified or the test will fail. This is useful in cases like this where, if
nothing else, you want to ensure that the <tt>close()</tt> method is called after all of the <tt>println()</tt> calls on
the writer. The whole test case is as follows: <br/><br/>
<pre class="brush:java">@RunWith(JMock.class)<br/>public class EmailListServlet_JMockTest {<br/> private Mockery mockery = new JUnit4Mockery();<br/> private EmailListServlet servlet;<br/> private HttpServletRequest request;<br/> private HttpServletResponse response;<br/> private EmailListService emailListService;<br/><br/> public EmailListServlet_JMockTest(){<br/>  mockery.setImposteriser(ClassImposteriser.INSTANCE);<br/> }<br/><br/> @Before<br/> public void before() throws ServletException {<br/>  this.emailListService = mockery.mock(EmailListService.class);<br/><br/>  final ServletConfig servletConfig = mockery.mock(ServletConfig.class);<br/>  mockery.checking(new Expectations(){<br/>   {<br/>    final ServletContext servletContext = mockery.mock(ServletContext.class);<br/>    one(servletConfig).getServletContext(); will(returnValue(servletContext));<br/>    one(servletContext).getAttribute(EmailListService.KEY); will(returnValue(emailListService));<br/>   }<br/>  });<br/><br/>  this.servlet = new EmailListServlet();<br/>  servlet.init(servletConfig);<br/><br/>  this.request = mockery.mock(HttpServletRequest.class);<br/>  this.response = mockery.mock(HttpServletResponse.class);<br/> }<br/><br/> @Test(expected=IOException.class)<br/> public void doGet_without_list() throws Exception {<br/>  mockery.checking(new Expectations(){<br/>   {<br/>    one(request).getParameter("listName"); will(returnValue(null));<br/>    one(emailListService).getListByName(null); will(throwException(new IOException()));<br/>   }<br/>  });<br/><br/>  servlet.doGet(request, response);<br/> }<br/><br/> @Test<br/> public void doGet_with_list() throws Exception {<br/>  final PrintWriter writer = mockery.mock(PrintWriter.class);<br/>  final Sequence printSequence = mockery.sequence("printSequence");<br/>  mockery.checking(new Expectations(){<br/>   {<br/>    one(request).getParameter("listName"); will(returnValue("foolist"));<br/><br/>    final List&lt;String&gt; list = Arrays.asList("larry@stooge.com","moe@stooge.com","curley@stooge.com");<br/>    one(emailListService).getListByName("foolist"); will(returnValue( list ));<br/>    one(response).getWriter(); will(returnValue(writer));<br/>    one(writer).println("larry@stooge.com"); inSequence(printSequence);<br/>    one(writer).println("moe@stooge.com"); inSequence(printSequence);<br/>    one(writer).println("curley@stooge.com"); inSequence(printSequence);<br/>    one(writer).close(); inSequence(printSequence);<br/>   }<br/>  });<br/><br/>  servlet.doGet(request, response);<br/> }<br/>}</pre>
<br/>JMock has a good amount of development time under its belt so it is pretty well documented and tested itself. It's
got a great API for writing your own parameter matchers, method matchers and expectations. It can be a bit cumbersome at
times when the test cases get large and full of a lot of mock plumbing. I tend to try and treat test code with the same
refactoring attention that I do normal code... pulling out shared expectations, and creating useful shared assertions,
etc, then it's not so bad. There is definitely more code involved with this approach than with something like spring
mock; however, you do have quite a wide range of mock-ability that you don't really get with predefined mock
implementations. <br/>
<blockquote>You can find the source code used in this posting in my <a
        href="http://github.com/cjstehno/coffeaelectronica/tree/master/tourdemock">TourDeMock</a> project.
</blockquote>
</body>
</html>
