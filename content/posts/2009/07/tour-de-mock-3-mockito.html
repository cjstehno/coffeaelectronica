
<html><head>
<title>Tour de Mock 3: Mockito</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2009-07-22T11:11:00.000-05:00" />
</head><body><a href="http://mockito.org/">Mockito</a> is a fairly new player in the mocking arena, but one that I have found particularly interesting. It's as expressive and flexible as <a href="http://jmock.org/">JMock</a> (from what I have seen so far) but it's a bit more compact and concise, which is something I really like. <br /><a name='more'></a>It's also got some nice annotation support that really helps cleans up the code.  If you look at the <tt>EmailListServlet_MockitoTest</tt> class you will see that again (as with JMock) the <tt>@RunWith</tt> annotation is used to provide a special test runner for Mockito. In this case it is used to evaluate the Mockito annotations. Another thing that you will notice is that instance variable mocks can be done with annotations in Mockito, using the <tt>@Mock</tt> annotation, very useful.  <br /><br /><pre class="brush:java">@RunWith(MockitoJUnit44Runner.class)<br />public class EmailListServlet_MockitoTest {<br /><br /> private EmailListServlet servlet;<br /><br /> @Mock<br /> private HttpServletRequest request;<br />}<br /></pre><br />The <tt>@Before</tt> method is somewhere between the Spring-mock and JMock complexity level:  <br /><br /><pre class="brush:java">@Before<br />public void before() throws ServletException {<br /> final ServletConfig servletConfig = mock(ServletConfig.class);<br /> final ServletContext servletContext = mock(ServletContext.class);<br /><br /> when(servletConfig.getServletContext()).thenReturn(servletContext);<br /> when(servletContext.getAttribute(EmailListService.KEY)).thenReturn(emailListService);<br /><br /> this.servlet = new EmailListServlet();<br /> servlet.init(servletConfig);<br />}</pre><br />Its as expressive as JMock but with less of the distracting overhead (no instance initialization block expectations) so it's a bit easier to read, and to maintain. The "without list name" test is almost as simple as it was in the spring-mock version:  <br /><br /><pre class="brush:java">@Test(expected=IOException.class)<br />public void doGet_without_list() throws Exception {<br /> when(request.getParameter("listName")).thenReturn(null);<br /> when(emailListService.getListByName(null)).thenThrow(new IOException());<br /><br /> servlet.doGet(request, response);<br />}</pre><br />Notice, too, that it reads fairly clear as to what is going on. "When you get this method call, return this". Again with the "with list name" test we see that Mockito also has good sequential call support:  <br /><br /><pre class="brush:java">@Test<br />public void doGet_with_list() throws Exception {<br /> final PrintWriter writer = mock(PrintWriter.class);<br /><br /> when(request.getParameter("listName")).thenReturn("foolist");<br /><br /> final List&lt;String&gt; list = Arrays.asList("larry@stooge.com","moe@stooge.com","curley@stooge.com");<br /> when(emailListService.getListByName("foolist")).thenReturn(list);<br /><br /> when(response.getWriter()).thenReturn(writer);<br /><br /> servlet.doGet(request, response);<br /><br /> final InOrder order = inOrder(writer);<br /> order.verify(writer).println("larry@stooge.com");<br /> order.verify(writer).println("moe@stooge.com");<br /> order.verify(writer).println("curley@stooge.com");<br /> order.verify(writer).close();<br />}<br /></pre><br />Another thing to point out here is that with Mockito, there is nothing special you need to to in order to mock out concrete classes, it just works. The whole test case using Mockito is shown below:  <br /><br /><pre class="brush:java">@RunWith(MockitoJUnit44Runner.class)<br />public class EmailListServlet_MockitoTest {<br /><br /> private EmailListServlet servlet;<br /><br /> @Mock<br /> private HttpServletRequest request;<br /><br /> @Mock<br /> private HttpServletResponse response;<br /><br /> @Mock<br /> private EmailListService emailListService;<br /><br /> @Before<br /> public void before() throws ServletException {<br />  final ServletConfig servletConfig = mock(ServletConfig.class);<br />  final ServletContext servletContext = mock(ServletContext.class);<br /><br />  when(servletConfig.getServletContext()).thenReturn(servletContext);<br />  when(servletContext.getAttribute(EmailListService.KEY)).thenReturn(emailListService);<br /><br />  this.servlet = new EmailListServlet();<br />  servlet.init(servletConfig);<br /> }<br /><br /> @Test(expected=IOException.class)<br /> public void doGet_without_list() throws Exception {<br />  when(request.getParameter("listName")).thenReturn(null);<br />  when(emailListService.getListByName(null)).thenThrow(new IOException());<br /><br />  servlet.doGet(request, response);<br /> }<br /><br /> @Test<br /> public void doGet_with_list() throws Exception {<br />  final PrintWriter writer = mock(PrintWriter.class);<br /><br />  when(request.getParameter("listName")).thenReturn("foolist");<br /><br />  final List&lt;String&gt; list = Arrays.asList("larry@stooge.com","moe@stooge.com","curley@stooge.com");<br />  when(emailListService.getListByName("foolist")).thenReturn(list);<br /><br />  when(response.getWriter()).thenReturn(writer);<br /><br />  servlet.doGet(request, response);<br /><br />  final InOrder order = inOrder(writer);<br />  order.verify(writer).println("larry@stooge.com");<br />  order.verify(writer).println("moe@stooge.com");<br />  order.verify(writer).println("curley@stooge.com");<br />  order.verify(writer).close();<br /> }<br />}</pre><br />I plan on spending some more time with Mockito as I could see it becoming my favourite mocking API.  <br /><blockquote>You can find the source code used in this posting in my <a href="http://github.com/cjstehno/coffeaelectronica/tree/master/tourdemock">TourDeMock</a> project.</blockquote></body></html>
