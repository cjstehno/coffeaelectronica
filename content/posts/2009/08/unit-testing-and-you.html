<html>
<head>
    <title>Unit Testing and You</title>
    <meta name="grackle.layout" content="post"/>
    <meta name="grackle.date-published" content="2009-08-09T10:21:00.000-05:00"/>
</head>
<body>
<div class="separator" style="clear: both; text-align: center;"><a
        href="http://3.bp.blogspot.com/-bWOhp2Zg1O0/T-8YqbJGZ0I/AAAAAAAAC9Q/nu5Z-S0O_ko/s1600/green-bar.png"
        imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0"
                                                                                                      src="http://3.bp.blogspot.com/-bWOhp2Zg1O0/T-8YqbJGZ0I/AAAAAAAAC9Q/nu5Z-S0O_ko/s1600/green-bar.png"/></a>
</div>
Unit testing seems to be one of the more misunderstood development practices. It tends to be viewed as adding too much
development time or maintenance overhead, when in the long run the reality is that you save development time and
maintenance overhead by taking care of potential bugs before they happen at the time when you are most engaged in the
code, rather than weeks or months later when you may have forgotten half what was done or are looking through someone
else's code.<br/><br/>The devoted unit testers often talk about being "test infected", and it really does happen. As
unit testing becomes more second nature to you and just part of your development cycle, you will feel a loss or uneasy
about the times when you cannot write tests for the code you are developing (generally a case when starting at a new
company that has not yet embraced unit testing). You feel wrong about not testing and that is a good thing.<br/><br/>In
my opinion, there is no excuse for not having at least some unit testing of your code. Ideally, the more coverage the
better; however, some is better than none. You don't have to get into "Test Driven Development" if you don't want to...
it does not appeal to every one, just learn to do "Test-centric Development", which is a phrase we coined at a company I
used to work for. It means development with good unit testing, though not necessarily done before the code.<br/><br/>So,
before I get too far off topic, let's go into the "Why", the "What" and the "Where" of unit testing, and then I will
talk about the basic tools you need to start testing.<br/><br/><strong>Why Write Unit Tests</strong><br/>Why should you
write unit tests? It's a question that I have heard many times. The best answer I have heard is <br/>
<blockquote>"how do you know your code works, if you don't test it?"</blockquote>
... and no, QA testing does not count because I have yet to come across a QA department that will regression test an
entire application every time you make a change to the code, they may exists, but not in any company I have ever heard
of. Unit testing your code provides a first line of defense against bugs and proof that your code does what it should.
In writing testing you are also using your code in a similar way that another developer will, meaning that your unit
tests can serve as a 100% accurate usage example and source of functional documentation. How often do your JavaDoc
comments actually reflect the behavior of the code? Unit test "documentation" will never be out of sync with the code;
it can't be, if it's not it will fail and you will have to fix it.<br/><br/>Unit testing also provides a level of
confidence around making changes. If you have ever had to change a significant amount of code with and without unit
tests, you will agree that you feel much more confident when you have good unit test coverage to prove that your changes
did not break anything unexpectedly.<br/><br/>The last point as to why we write unit test is that you can then have them
runnable on command and/or automated by the build process, before check-ins, etc. so that you know you are building your
artifacts or checking into source control a clean set of code... again part of the confidence.<br/><br/><strong>What do
    I Unit Test?</strong><br/>Ideally, unit testing should be all-pervasive; every path through every method of every
class (not interfaces) should be tested through various scenarios including normal values, boundary conditions and
exceptions. Unfortunately, this ideal case is not always practical. So it boils down to "do the best you can".<br/><br/>Most
of us are not lucky enough to be starting a project from scratch. When you come into an untested project a month or a
year into it's development you need to be realistic and draw a "line in the sand" such that from this point forward we
will unit test our code to the best of our abilities. The older "legacy" code can be picked at and tested as feature
requests and bugs cause you to delve into those untested waters.<br/><br/><strong>Where do Unit Tests Go?</strong><br/>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"
       style="float: left; margin-right: 1em; text-align: left;">
    <tbody>
    <tr>
        <td style="text-align: center;"><a
                href="http://4.bp.blogspot.com/-dZHhDvUkK1U/T-8Y0vOI5GI/AAAAAAAAC9Y/o4SY9aU5BG4/s1600/testing-separation.png"
                imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0"
                                                                                    src="http://4.bp.blogspot.com/-dZHhDvUkK1U/T-8Y0vOI5GI/AAAAAAAAC9Y/o4SY9aU5BG4/s1600/testing-separation.png"/></a>
        </td>
    </tr>
    <tr>
        <td class="tr-caption" style="text-align: center;">Separation of production source and test source.</td>
    </tr>
    </tbody>
</table>
Unit test source code should reside in a separate directory structure from the "production" source code, and should also
be compiled into a separate class directory structure; however, the package structure in the test source and production
source directories should be the same.<br/><br/>Generally you should not release test source or compiled test code into
a production environment, or in most cases even a testing/QA environment (unless you have specific test cases that are
run in QA only). The separation of test source and classes from the production source and classes makes this filtering
easier. The world will not end if you do allow your testing code into production; it is really more a matter of limiting
the bulk of your production artifacts.<br/><br/>This separation does not in any way hinder your ability to have your
test classes access the classes they are trying to test. Everything is still on the same classpath. In your IDE you
would just mount both as source directories and everything would work seamlessly. Some IDEs do provide additional
support for defining test directories in a slightly different way than normal source directories, but you will have to
look into that on your own.<br/><br/><strong>Running Unit Tests</strong><br/>There are a variety of ways to run your
unit tests. You can run tests using the JUnit test runner from the command line (from <a
        href="http://junit.org/">JUnit</a>):<br/><br/>
<pre class="brush:text">java org.junit.runner.JUnitCore TestClass1.class [...other test classes...]</pre>
<br/>If you are using <a href="http://ant.apache.org/">Ant</a>, you can add a target to run your tests: <br/><br/>
<pre class="brush:xml">&lt;target name="test" depends="compile"&gt;<br/>    &lt;junit printsummary="yes" haltonfailure="yes"&gt;<br/>        &lt;classpath refid="test.runtime.classpath" /&gt;<br/>        &lt;formatter type="plain" /&gt;<br/>        &lt;batchtest fork="yes" todir="${test.report.dir}"&gt;<br/>            &lt;fileset dir="${test.build.dir}" includes="**/*Test.class" /&gt;<br/>        &lt;/batchtest&gt;<br/>    &lt;/junit&gt;<br/>&lt;/target&gt;<br/></pre>
<br/>Once that is in place you can run your tests with: <br/><br/>
<pre class="brush:text">ant test</pre>
<br/>You can use <a href="http://maven.apache.org/">Maven</a>, which will "strongly suggest" where you should put your
production and test source code, following the convention over configuration approach to development. Once your tests
are in place or you have reconfigured Maven to your project setup you can run: <br/><br/>
<pre class="brush:text">mvn test</pre>
<br/>which will generate a simple console-based test report. <br/><br/>
<pre class="brush:text">-------------------------------------------------------<br/> T E S T S<br/>-------------------------------------------------------<br/>Running net.sourceforge.codeperks.io.zip.ZipBuilderTest<br/>Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.159 sec<br/>Running net.sourceforge.codeperks.io.IoTemplateTest<br/>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.01 sec<br/><br/>Results :<br/><br/>Tests run: 7, Failures: 0, Errors: 0, Skipped: 0<br/></pre>
<br/>Generally, you will probably be running your tests in your editor-of-choice, rather than the command
line.<br/><br/>
<table cellpadding="0" cellspacing="0" class="tr-caption-container"
       style="float: left; margin-right: 1em; text-align: left;">
    <tbody>
    <tr>
        <td style="text-align: center;"><a
                href="http://3.bp.blogspot.com/-mYHnj_wDja0/T-8ZLyYcioI/AAAAAAAAC9o/MRfi7wiqRe4/s1600/testing-runineclipse.png"
                imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img
                border="0"
                src="http://3.bp.blogspot.com/-mYHnj_wDja0/T-8ZLyYcioI/AAAAAAAAC9o/MRfi7wiqRe4/s1600/testing-runineclipse.png"/></a>
        </td>
    </tr>
    <tr>
        <td class="tr-caption" style="text-align: center;">Eclipse JUnit Runner results.</td>
    </tr>
    </tbody>
</table>
Or you can run JUnit tests from pretty much any IDE on the market. The image is an example of the <a
        href="http://eclipse.org/">Eclipse</a> JUnit test runner and its results. As you can see it shows you which
tests passed and which tests failed, if any. It also shows you how long each took to run.<br/><br/>You also see the
"green bar" that you will hear avid testers talk about. If any of your tests do not pass, the green bar will be red to
let you know that bad things have happened (hence the logo at the beginning of this article, "Embrace the Green
Bar").<br/><br/>That should be enough project setup and general testing talk, how about we set up some good habits now
with a healthy dose of "best practices" for unit testing.<br/><br/><strong>Best Practices</strong><br/>When you write
unit tests, you should treat them like real code. Pull out common code into shared classes, refactor repeated
functionality into methods just like you would with the code you are testing. Also, you should use expressive names for
your tests; the test case class should be named the same as the class you are testing with "Test" added to the end and
your actual test methods should be named with underscores rather than the normal camel case notation (this is one of
those opinion items, but the underscores do read better in test reports). As an example: <br/><br/>
<pre class="brush:java">public void handleRequest_with_null_userId(){}</pre>
<br/>reads a bit more easily, in my opinion, than <br/><br/>
<pre class="brush:java">public void handleRequestWithNullUserId(){}</pre>
<br/>Either is fine and technically correct, though some developers prefer one over the other.<br/><br/>One very
important concept in good unit testing is the practice of coding to interfaces rather than implementations. Components
such as services and DAOs should be interface-driven, meaning that you have an interface <tt>SomeDao</tt> that is
implemented by <tt>SomeHibernateDao</tt> so that your code uses the interfaces rather than the actual implementation
class. This promotes decoupling and allows for greater flexibility in testing as well as stronger unit test
isolation.<br/><br/>The example below shows an API for some temperature sensing hardware. The
<tt>TemperatureHardware</tt> interface has a standard implementation called <tt>DX39TemperatureHardware</tt> (made up)
which access the hardware layer to get data from thermocouples regarding the temperature. <br/><br/>
<pre class="brush:java">public interface TemperatureHardware {<br/>    double getTemperature( short tcid );<br/>}<br/><br/>public class DX39TemeratureHardware implements TemperatureHardware {<br/>    public double getTemperature( short tcid ){<br/>        // some fancy native hardware-specific stuff<br/>    }<br/>}<br/></pre>
<br/>So now in testing this code, you can base your testing around the use of the interface because chances are you
don't actually have the hardware itself. Coding to interfaces makes it much easier to integrate mock objects into your
unit testing, and mock objects, you will eventually find to be an indispensable part of unit testing.<br/><br/>I have
written quite a few posts about <a href="http://www.coffeaelectronica.com/search/label/Mocks">testing with mocks</a> but
to summarize; mocking is the replacement of the complex (or even not so complex) dependencies of the object being tested
with mocked out versions of those objects so that you can control their behavior and help isolate the test.<br/><br/>I
will leave the mocking examples to the referred postings as they go into the uses of mocking in greater detail than I
would here.<br/><br/><strong>Conclusion</strong><br/>That about summarizes my thoughts on unit testing. Most of this has
been gone over and over on various blogs, books, and presentations, but I felt it important enough to present it one
more time. Unit testing often gets lumped into the same box as agile and extreme programming which can put a bad taste
on it when some projects/teams are looking into testing. I have nothing against extreme programming, but I have run
across organizations that have a real negative attitude towards it and see unit testing as just "another one of those
fluffy feel good code-hippie things". It's really not. Embrace the green bar and join us on the testing side.<br/><br/>As
a foot note I recommend reading "<a
        href="http://www.amazon.com/gp/product/0974514012?ie=UTF8&amp;tag=coffeael-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0974514012">Pragmatic
    Unit Testing in Java with JUnit</a><img alt="" border="0" height="1"
                                            src="http://www.assoc-amazon.com/e/ir?t=coffeael-20&amp;l=as2&amp;o=1&amp;a=0974514012"
                                            style="border: none !important; margin: 0px !important;" width="1"/>" and
the <a href="http://junit.org/">JUnit</a> web site documentation for more information about testing with
JUnit.<br/><br/>As a foot note to the foot note, I will also add that JUnit is not the only unit testing tool available
for Java, there is another called <a href="http://testng.org/">TestNG</a>, which I tried a few years back. It seemed
good and some people swear by it; however, the tool support for it seemed to lag behind that for JUnit and I have always
been comfortable with the features provided by JUnit, so I never saw a need to switch.
</body>
</html>
