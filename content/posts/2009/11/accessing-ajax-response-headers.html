
<html><head>
<title>Accessing Ajax Response Headers</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2009-11-03T11:15:00.000-06:00" />
</head><body>One way to handle error responses with Ajax requests is to add an HTTP Response Header to the response, denoting the resulting command status, while still returning content or data related to the error in the response.<br /><a name='more'></a> Generally when using Ajax calls you don't want a raw exception or server error to bubble up to your JavaScript handlers.  Let's say we have a simple quote service at "blurb.jsp":  <br /><br /><pre class="brush:html">&lt;%@page import="java.util.Random"%&gt;<br />&lt;%!<br /> private static final Random rng = new Random();<br /> private static final String[] quotes = {<br />  "I regret that I have but one life to live for my country.",<br />  "To be or not to be, that is the question...",<br />  "I drank what?",<br />  "I am what I am and that's all I am"<br /> };<br />%&gt;<br />&lt;%<br /> try {<br />        // WARNING: intentional random error below<br />  final String quote = quotes[rng.nextInt(quotes.length+1)];<br />  <br />  response.setContentType("text/plain");<br />  response.setHeader("X-Status","OK");<br />  out.write(quote);<br />  <br /> } catch(Exception e){<br />  response.setHeader("X-Status","ERR");<br />  out.write("Something bad has happened: " + e.getMessage());<br /> } finally {<br />  out.close();<br /> }<br />%&gt;<br /></pre><br />All this does is setup some simple quote strings and randomly provide one of them as a text response. I have added an error condition by allowing the random number generated to exceed the maximum index of the array so that we can get a random error response. In both cases, success or failure, the response header "X-Status" is given a value of "OK" or "ERR" respectively to denote the type of response being sent.  Handling this response with <a href="http://prototypejs.com/">Prototype</a> is pretty simple:  <br /><br /><pre class="brush:html">&lt;html&gt; <br />    &lt;head&gt; <br />        &lt;script type="text/javascript" <br />            src="http://ajax.googleapis.com/ajax/libs/prototype/1.6.1.0/prototype.js"&gt;&lt;/script&gt;<br />        &lt;script type="text/javascript"&gt;<br />            Event.observe(window,'load',function(){<br />                $('quote').observe('click',handleClick);<br />            });<br />            <br />            function handleClick(evt){<br />    new Ajax.Request('blurb.jsp', {<br />     onSuccess: function(response) {<br />      var quoteElt = $('quote');<br />      if( 'ERR' == response.getHeader('X-G-Status') ){<br />       quoteElt.setStyle({color:'red'});<br />      } else {<br />       quoteElt.setStyle({color:'black'});<br />      }<br />      quoteElt.update(response.responseText);<br />     }<br />    });<br />            }<br />        &lt;/script&gt;<br />    &lt;/head&gt;<br />    &lt;body&gt;<br />    <br />        &lt;blockquote id="quote" style="border:1px dashed green;padding:4px;"&gt;Click me for a quote...&lt;/blockquote&gt;<br />    <br />    &lt;/body&gt;<br />&lt;/html&gt;<br /></pre><br />Basically, in your "onSuccess" handler function you just pull the header value out of the response object. You could conceivably do any kind of response handling you wanted for an "error" response. In the little demo, you will get a quote from the server each time you click on the quote box; successful quotes will be black, while errors will be in red text.  For the heck of it, I decided to try the same thing in <a href="http://jquery.com/">JQuery</a> (without making a whole separate post about it). I am just including the script sections, since they are the only difference:  <br /><br /><pre class="brush:html">&lt;script type="text/javascript" <br />    src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"&gt;&lt;/script&gt;<br />&lt;script type="text/javascript"&gt;<br />    jQuery(function(){<br />        $('#quote').bind('click',handleClick);<br />    });<br />    <br />    function handleClick(evt){<br />        var jqr = jQuery.get(<br />            'blurb.jsp', <br />            function(text){<br />                var quoteElt = $('#quote');<br />                if( 'ERR' == jqr.getResponseHeader('X-Status') ){<br />                    quoteElt.css('color','red');<br />                } else {<br />                    quoteElt.css('color','black');<br />                }<br />                quoteElt.html(text);<br />            },<br />            'text'<br />        );<br />    }<br />&lt;/script&gt;<br /></pre><br />Surprisingly enough, this was a bit more difficult (or convoluted) to do with JQuery since JQuery does not seem to provide any wrapper access to the response itself. You have to use the XMLHTTPRequest object, which works fine but as you can see in the Ajax callback it leads to some interesting code; the <tt>jqr</tt> varible contains the request object and is used inside the callback function. It just feels a lot less clean.   Maybe I am not clear on how to use the JQuery Ajax support yet and I am missing something simple... or the developers of JQuery decided that since the times you actually need the response object itself are pretty limited, they could get away without providing direct access. Ultimately though, the support is there and that's what's really important.</body></html>
