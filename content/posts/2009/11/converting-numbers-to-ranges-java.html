<html>
<head>
    <title>Converting Numbers to Ranges: Java</title>
    <meta name="grackle.layout" content="post"/>
    <meta name="grackle.date-published" content="2009-11-22T20:14:00.000-06:00"/>
</head>
<body>Yesterday I posted my Python code for the <a
        href="http://www.coffeaelectronica.com/2009/11/converting-numbers-to-ranges-python.html">Converting Numbers to
    Ranges</a> problem. Today I decided to do a quick Java implementation.<br/><a name='more'></a> <br/>
<pre class="brush:java">public class HomeOnTheRange {<br/><br/>    public static void main( final String[] args ) {<br/>        System.out.println( convertToRanges( args ) );<br/>    }<br/><br/>    public static String convertToRanges(final String[] args){<br/>        final int[] nums = new int[args.length];<br/>        for( int n=0; n&lt;args.length; n++){<br/>            nums[n] = Integer.valueOf( args[n] );<br/>        }<br/><br/>        String hold = null;<br/>        final StringBuilder str = new StringBuilder();<br/><br/>        for(int i=0; i&lt;args.length; i++){<br/>            if( i+1 &lt; args.length &amp;&amp; nums[i]+1 == nums[i+1] ){<br/>                if(hold == null) hold = args[i];<br/>            } else {<br/>                if(hold != null){<br/>                    str.append(hold).append('-').append(args[i]).append(", ");<br/>                    hold = null;<br/>                } else {<br/>                    str.append( args[i] ).append(", ");<br/>                }<br/>            }<br/>        }<br/><br/>        str.delete( str.length()-2, str.length() ).append( '.' );<br/><br/>        return str.toString();<br/>    }<br/>}<br/></pre>
<br/>There is not much difference from the Python version; I guess with simple problems like these you are going to end
up with pretty much the same form of solution unless you can find some tricky little piece of the language that works
better as a solution. One thing I did different in the Java solution is that I pre-converted the argument String array
into an integer array. I noticed that you really end up doing the string to int conversion twice for most of the input
elements, which in Java can really add up for a large data set. I wonder if the same problem is inherent in the python
solution? I also did the ending period a little different here, simple deleting the end of the string buffer and adding
a period; an approach similar to the python version would probably be a little better, but either way is fine. I guess
you could write a separate method to do the string to int conversion and then cache the results so that you are still
doing the conversion once and "inline" with the main loop.<br/><br/>With a little thought about the problem space you
can see that each string is converted and used at most twice, so you can setup the caching to convert and cache on the
first use and then just return the converted int on the second call. <br/><br/>
<pre class="brush:java">public class HomeOnTheRange2 {<br/><br/>    private static final ThreadLocal&lt;Converter&gt; converter = new ThreadLocal&lt;Converter&gt;(){<br/>        @Override<br/>        protected Converter initialValue() {<br/>            return new Converter();<br/>        };<br/>    };<br/><br/>    public static void main( final String[] args ) {<br/>        System.out.println( convertToRanges( args ) );<br/>    }<br/><br/>    public static String convertToRanges(final String[] args){<br/>        String hold = null;<br/>        final StringBuilder str = new StringBuilder();<br/><br/>        final Converter conv = converter.get();<br/>        for(int i=0; i&lt;args.length; i++){<br/>            if( i+1 &lt; args.length &amp;&amp; conv.toInt( args[i] )+1 == conv.toInt( args[i+1] )){<br/>                if(hold == null) hold = args[i];<br/>            } else {<br/>                if(hold != null){<br/>                    str.append(hold).append('-').append(args[i]).append(", ");<br/>                    hold = null;<br/>                } else {<br/>                    str.append( args[i] ).append(", ");<br/>                }<br/>            }<br/>        }<br/><br/>        str.delete( str.length()-2, str.length() ).append( '.' );<br/><br/>        return str.toString();<br/>    }<br/><br/>    private static final class Converter {<br/><br/>        private String key;<br/>        private int value;<br/><br/>        public int toInt(final String str){<br/>            if( !str.equals( key ) ){<br/>                this.key = str;<br/>                this.value = Integer.valueOf( str );<br/>            }<br/>            return value;<br/>        }<br/>    }<br/>}<br/></pre>
<br/>You will see that this code no longer does the initial conversion loop. The string to int conversion is now done
using the <tt>Converter</tt> class, which simply converts and caches the value on the first request for a value, and
will simply return the cached int for a second call of the same number. This makes the assumption that the numbers are
in ascending order, which is valid for this problem. I also added the converter as a <tt>ThreadLocal</tt> variable since
this conversion is now very tied to the order in which the values are converted. Making it thread-safe ensures that two
calls to this method on different threads will not mess with each others values.<br/><br/>I considered just using a Map
of some sort, but without some sort of bounds you end up caching every number, when as you can see you really only need
one. Technically delving that deep into the problem to come up with a custom caching solution is really premature
optimization, which is generally a bad thing. You should just to the original conversion as needed and then do the
followup refactoring if performance bottlenecks lead you to do so.
</body>
</html>
