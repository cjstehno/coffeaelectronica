
<html><head>
<title>When GStrings Attack!</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2012-03-28T08:17:00.003-05:00" />
</head><body><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-g6R-VtUfJZo/T3MQ51haJXI/AAAAAAAAC0U/_A0IkeoMfWc/s1600/strings.jpg" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-g6R-VtUfJZo/T3MQ51haJXI/AAAAAAAAC0U/_A0IkeoMfWc/s1600/strings.jpg" /></a></div>I have run into this behavior a few times now, so I decided to dig into it a bit. Basically, if you have a map using "string" keys in <a href="http://groovy.codehaus.org/" target="_blank">Groovy</a>, they can provide unexpected (or at least non-intuitive results).<br /><br /><a name='more'></a>Groovy has two object types of "string"... the standard Java String, which is denoted by single-quotes, and the dynamic GString, which is denoted by double-quotes <i>(Note: the current version of the documentation has a nice outline of <a href="http://groovy.codehaus.org/Strings+and+GString" target="_blank">Strings vs GStrings</a>)</i>. From a developer perspective these generally seem interchangable other than the dynamic nature of GStrings; however, there is a more fundamental difference when you are working with hashes (Sets and Maps) since these are not the same class.<br />Let's consider the following two strings:<br /><br /><pre class="brush:groovy">def str = 'foo2'<br />def gstr = "foo${1+1}"</pre><br />Yes, the 1+1 is a bit contrived, but it's where the fun comes in. If you check them for equality:<br /><br /><pre class="brush:groovy">println( str == gstr )<br />println( str.equals( gstr ) )</pre><br />The first line (==), will print "true", while the second line (equals) will print "false". But, wait, there's more...<br /><br /><pre class="brush:groovy">println( str.hashCode() == gstr.hashCode() )</pre><br />will print "false". They are two different instances of two different classes, lightly hidden by a layer of similarity. As a developer, you can get used to not thinking about the differences, especially when they are not always visible. Consider the case when both strings have the same non-dynamic content:<br /><br /><pre class="brush:groovy">def str = 'foo2'<br />def gstr = "foo2"<br /><br />println( str == gstr )<br />println( str.equals( gstr ))<br />println( str.hashCode() == gstr.hashCode() )</pre><br />In this scenario, all three lines print "true". So really what it comes down to is the cases when there is actually dynamic content in the GString. These will be considered differently than a seemingly equivalent static string.<br />This is can be a dangerous difference when working with maps:<br /><br /><pre class="brush:groovy">def map = [:]<br />map.put( 'foo2', 1 )<br />map.put( "foo${1+1}" as String, 2 )<br />map.put( "foo${1+1}", 3 )<br /><br />println "map.size() -&gt; ${map.size()}"<br />map.each {k,v-&gt;&nbsp;<br />    println "$k = $v"<br />}<br /><br />println map['foo2'] // 2<br />println map["foo2"] // 2<br />println map["foo${1+1}"] // 2</pre><br />If you add a similar string in three different ways (static string, GString cast as String, and GString), you will see that it results in:<br /><br /><pre class="brush:groovy">map.size() -&gt; 2<br />foo2 = 2<br />foo2 = 3<br />2<br />2<br />2</pre><br />You end up with two unique entries in the map, though only one of them is accessible directly.<br />I don't really feel that this is a bug in Groovy; however, more of an unexpected behavior that can play against what a developer might feel is intuitive (e.g. a string is a string). This is just something to beware of while developing in Groovy.</body></html>
