
<html><head>
<title>Embedding Jetty in Spring</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2006-02-01T18:08:00.000-06:00" />
</head><body><blockquote>The discussion here is based on Jetty 5, while Jetty 6 makes things a lot easier to do. I have an updated version of this post for Jetty 6, <a href="http://www.coffeaelectronica.com/2008/08/embedding-jetty-6-in-spring.html">Embedding Jetty 6 in Spring</a>.</blockquote>I came across <a href="http://jetty.mortbay.org/">Jetty</a> a while back and finally got around to really playing with it recently. I was amazed at how flexible it was and how easy it was to embed it inside a <a href="http://springframework.org/">Spring</a> Application Context. I did have to write a couple of small helper extensions to ease things along but other than that it was pretty much just a configuration exercise. What follows is a brief discussion on what I did and how I did it.<br /><a name='more'></a>Basically what you need, per the Jetty documentation, is an <tt>HttpServer</tt> instance listening on a port, and an <tt>HttpContext</tt> with a couple <tt>Handler</tt>s. If all you want is a simple web server, with no servlet support it’s very easy and requires no special extensions. Add the following beans to a spring bean config file:<br /><br /><br /><pre class="brush:xml">&lt;bean id='httpServer' class='org.mortbay.http.HttpServer' init-method='start'&gt;<br />    &lt;property name='listeners'&gt;<br />            &lt;list&gt;<br />                    &lt;bean class='org.mortbay.http.SocketListener'&gt;<br />                            &lt;property name='port' value='80' /&gt;<br />                    &lt;/bean&gt;<br />            &lt;/list&gt;<br />    &lt;/property&gt;<br />    &lt;property name='contexts'&gt;<br />        &lt;list&gt;<br />            &lt;bean class='org.mortbay.http.HttpContext'&gt;<br />                &lt;property name='contextPath' value='/' /&gt;<br />                &lt;property name='resourceBase' value='c:/' /&gt;<br />                &lt;property name='handlers'&gt;<br />                    &lt;list&gt;<br />                        &lt;bean class='org.mortbay.http.handler.ResourceHandler'/&gt;<br />                    &lt;/list&gt;<br />                &lt;/property&gt;<br />            &lt;/bean&gt;<br />        &lt;/list&gt;<br />    &lt;/property&gt;<br /> &lt;/bean&gt;<br /></pre><br />Now, when you start up the Spring Application Context you will also start up an HTTP Server listening on port 80 that will serve pages from your <tt>C</tt> drive. How much simpler could that be? You could get rid of the <tt>init-method</tt> and set <tt>lazy-init</tt> to true if you don’t need/want it to fire up right away.<br /><br />Okay, so web server shmeb server you say? Let’s get down to something more interesting. Now, let’s turn this plain old HTTP server into a servlet container... amazingly enough, there is not much more required to make this happen; however, we do need some extensions in order to work with things in Spring.<br /><br />First, we will need an instance of <tt>ServletHttpContext</tt> instead of the HTTP Context that we have in there now (or you could set it up to use both). Unfortunately, the standard <tt>ServletHttpContext</tt> class only has "add" methods for adding servlets... there is no bulk setter; so we have to add one, which leads up to our first helper class, the <tt>ServlerHttpContextBean</tt>. All this class does is extend <tt>ServletHttpContext</tt> and add the following method:  <br /><br /><pre class="brush:java">public void setServletMappings(Map servletMappings) throws Exception {<br />    if(MapUtils.isNotEmpty(servletMappings)){<br />  Iterator paths = servletMappings.keySet().iterator();<br />  while(paths.hasNext()){<br />   String path = (String)paths.next();<br />   ServletDefinitionBean servletConfig = (ServletDefinitionBean)servletMappings.get(path);<br />    // add the servlet to the context<br />   ServletHolder holder = addServlet(<br />    servletConfig.getBeanName(),<br />    path,<br />    servletConfig.getServletClassName()<br />   );<br /><br />   // configure the holder<br />   if(holder != null){<br />    if(servletConfig.getInitOrder() != -1){<br />     holder.setInitOrder(servletConfig.getInitOrder());<br />    }<br /><br />    Enumeration e = servletConfig.getInitParameterNames();<br />    while(e.hasMoreElements()){<br />     String name = (String)e.nextElement();<br />     holder.setInitParameter(<br />      name,<br />      servletConfig.getInitParameter(name)<br />     );<br />    }<br />   }<br />  }<br />    }<br />}</pre><b><br /></b><br /><b>Note:</b> Some of my collection helper classes are not shown, but their method signatures should be a good enough explanation of what they do.<br /><br />The servlet mappings (Path key to <tt>ServletDefinitionBean</tt> value) are processed to add each servlet to the context and then configure its holder to set any initialization parameters.<br /><br />You will notice the other helper class being used to configure the servlets. The <tt>ServletDefinitionBean</tt> is used to allow Spring configuration of the servlets to be added. This is a fairly simple class:  <br /><br /><pre class="brush:java">public class ServletDefinitionBean implements Serializable,BeanNameAware {<br /><br />    private static final long serialVersionUID = 8232043638313653802L;<br />    private String beanName,servletClassName;<br />    private Map initParameters;<br />    private int initOrder = -1;<br /><br />    public ServletDefinitionBean(){super();}<br /><br />    public void setInitOrder(int initOrder) {this.initOrder = initOrder;}<br /><br />    public int getInitOrder() {return initOrder;}<br /><br />    public String getServletClassName() {return servletClassName;}<br /><br />    public void setServletClassName(String servletClass) {<br />  this.servletClassName = servletClass;<br />    }<br /><br />    public String getBeanName() {return beanName;}<br /><br />    public void setBeanName(String beanName) {this.beanName = beanName;}<br /><br />    public void setInitParameters(Map initParameters){<br />  this.initParameters = initParameters;<br />    }<br /><br />    public Enumeration getInitParameterNames(){<br />  if(MapUtils.isNotEmpty(initParameters)){<br />   return(IteratorUtils.asEnumeration(<br />    initParameters.keySet().iterator())<br />   );<br />  } else {<br />   return(CollectionUtils.EMPTY_ENUMERATION);<br />  }<br />    }<br /><br />    public String getInitParameter(String name){<br />  return(MapUtils.getString(initParameters,name));<br />    }<br />}<br /></pre><br />This class is used to store the initialization parameters and any other data required to configure a servlet. And that’s it. Now all you need to do is update the spring configuration to use the new beans.   <br /><br /><pre class="brush:xml">&lt;bean id='httpServer' class='org.mortbay.http.HttpServer' init-method='start'&gt;<br />    &lt;property name='listeners'&gt;<br />  &lt;list&gt;<br />   &lt;bean class='org.mortbay.http.SocketListener'&gt;<br />      &lt;property name='port' value='80' /&gt;<br />   &lt;/bean&gt;<br />  &lt;/list&gt;<br />    &lt;/property&gt;<br />    &lt;property name='contexts'&gt;<br />  &lt;list&gt;<br />   &lt;bean class='com.stehno.spring.jetty.ServletHttpContextBean'&gt;<br />    &lt;property name='contextPath' value='/' /&gt;<br />    &lt;property name='resourceBase' value='c:/' /&gt;<br />    &lt;property name='handlers'&gt;<br />    &lt;list&gt;<br />    &lt;bean class='org.mortbay.http.handler.ResourceHandler' /&gt;<br />    &lt;bean class='org.mortbay.jetty.servlet.ServletHandler' /&gt;<br />    &lt;/list&gt;<br />    &lt;/property&gt;<br />    &lt;property name='servletMappings'&gt;<br />     &lt;map&gt;<br />     &lt;entry key='/hi/*' value-ref='helloServlet'/&gt;<br />     &lt;/map&gt;<br />    &lt;/property&gt;<br />   &lt;/bean&gt;<br />  &lt;/list&gt;<br />    &lt;/property&gt;<br />&lt;/bean&gt;<br /></pre><br />You will notice that in order to serve normal resources, you still need to include a <tt>ResourceHandler</tt>. I have mapped the 'helloServlet' to the path '/hi/*'. The servlet definition bean is configured as follows:  <br /><br /><pre class="brush:xml">    &lt;bean id='helloServlet' class='com.stehno.spring.jetty.ServletDefinitionBean'&gt;<br />        &lt;property name='servletClassName' value='test.HelloServlet' /&gt;<br />        &lt;property name='initParameters'&gt;<br />   &lt;map&gt;<br />    &lt;entry key='text' value='Hello Jetty-embedded Spring!' /&gt;<br />   &lt;/map&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /></pre><br />It’s just a simple Hello World type servlet that I will leave you to write yourself. But, if you fire up the Application Context and point your browser to 'http://localhost/hi/blah' you will run this servlet.<br /><br />I have not fully put this through its paces, but I have installed and run a Spring Dispatcher servlet that had its own application context with controllers and was able to hit the controllers and get the expected response. Jetty seems to be well-developed and very flexible and combining it with spring makes it even more so. I think there are many uses for this setup. It could be used in a desktop application to provide web services, for unit testing of servlets or controllers, or for web proxy-ing.</body></html>
