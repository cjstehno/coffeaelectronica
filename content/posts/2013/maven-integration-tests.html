<!DOCTYPE html>
<html>
<head>
    <title>Integration Testing with JUnit and Maven</title>
    <meta name="grackle.date-published" content="2/09/2013" />
    <meta name="grackle.layout" content="post" />
    <meta name="grackle.tags" content="JUnit,Maven" />
    <meta name="grackle.summary" content="Sometimes you need to test more of the interactions between components than mocking will allow." />
</head>
<body>
<p>When I talk about unit testing, I generally mean small quick and mocked tests of individual chunks of functionality,
    traditional unit testing. In some cases I will be testing slightly larger chunks, such as the interaction of a
    controller and a service, with everything else mocked out; however, when you start using a real database
    (especially not an embedded one) or needing to connect to other services in order to get a good solid test, you
    cross over into the realm of integration testing.</p>

<p>Recently on one of my projects I had DAO integration tests that require a real database to test against, and it is
    not embeddable (PostgreSQL using some non-standard features). I used a system property check to ensure that these
    integration tests only ran when I wanted them to so that I could ensure that there was a database ready to test
    against. You would have something like the following in your unit test:</p>

<pre>assumeTrue( "true".equalsIgnoreCase(System.getProperty("integration")) );</pre>

<p>which would only continue with the test if the assumption was true, otherwise it stops without failing the test.
    With this, when I wanted to run the integration tests I would just run them with that property, e.g.:</p>

<pre>mvn test -Dintegration=true</pre>

<p>This works, and it's not a horrible solution, but it does get annoying when testing from an IDE since you have to
    keep setting that property on any new test runners, which can slow things down.</p>

<p>A better way would be to have the test be no different than any other test so that if you want to run it, you run
    it, if not, you don't. I figured that there had to be a solution to this problem out there so a little research
    was in order. I found out that maven has an "integration-test" phase (since Maven 3) and that there is a fork of
    the surefire testing plugin called failsafe to take advantage of this build phase.</p>

<p>Surefire is the unit test running plugin used by maven. You usually don't even realize it's there; Unless you have
    some special configuration needs it just runs your tests for you. The failsafe fork of the plugin does the same
    functionality but with slightly different configuration. Failsafe looks for tests ending in "IT" for "integration
    test" rather than "Test" as a normal JUnit test. Also, failsafe runs in the integration-test phase rather rather
    than the test phase.</p>

<p>Now what I needed was a simple way to take advantage of this build phase. I could have used the naming patterns, but
    I prefer the "Test" suffix and wanted another option. I found an interesting alternative, the experimental
    categories feature in JUnit (4.9+).</p>

<p>To get this running, you need to have something like the following config in your maven build plugins:</p>

		<pre>
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.13&lt;/version&gt;
    &lt;configuration&gt;
        &lt;excludedGroups&gt;com.coffeaelectronica.Integration&lt;/excludedGroups&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.13&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;integration-test&lt;/goal&gt;
                &lt;goal&gt;verify&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;groups&gt;com.coffeaelectronica.Integration&lt;/groups&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*Test.*&lt;/include&gt;
        &lt;/includes&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</pre>

<p>This tells surefire to ignore any JUnit tests annotated with the Integration annotation and then configures failsafe
    to only consider classes ending in "Test" and having the Integration annotation. Remember, by default failsafe
    looks for "**/*IT.*".</p>

<p>With this, your tests either have no Category annotation, for a normal test, or something like the example shown
    below for Integration tests:</p>

	<pre>@Category(Integration.class)
public class SomeDaoTest {
    // your integration test methods...
}</pre>

<p>Now, when you run:</p>

<pre>mvn test</pre>

<p>You get only your normal unit tests being run, while running</p>

<pre>mvn integration-test</pre>

<p>will run only your integration tests.</p>

<p>Along with this, you retain the ability to run any single test in your IDE without having to do any extra configuration.</p>

</body>
</html>