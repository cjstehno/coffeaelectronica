
<html><head>
<title>JUnit Rules</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2013-03-28T07:11:00.001-05:00" />
</head><body>No, the title is not simply an expression of my love of <a href="http://junit.org/">JUnit</a>, but rather specifies that I will be talking about the <code>@Rule</code> annotations provided by JUnit... and yes, they do "rule".<br /><a name='more'></a><br />Out of the box, JUnit has a <a href="https://github.com/junit-team/junit/wiki/Rules">handful of useful rules</a> defined for things like temporary folder and test timeouts. With this post I am going to focus on writing my own rules using extensions of the <a href="https://github.com/junit-team/junit/wiki/Rules#externalresource-rules">ExternalResource</a> rule class.<br /><br />Suppose we are doing some unit testing of database access code using JDBC. Mocking direct JDBC calls is tedious and not very productive so we will be using a real database for testing. To keep this post a simple and straight-forward as possible without forsaking useful content, I am going to use Groovy for the examples and assume that we are using the Spring JDBC framework and some random database.<br /><br />We have a PersonDao for storing the name and email address of people in the database.  <br /><br /><pre class="brush:groovy">class PersonDao {<br /><br />    JdbcTemplate jdbcTemplate<br /><br />    void createPerson( person ){<br />        jdbcTemplate.update('insert into people (name,email) values (?,?)', person.name, person.email )<br />    }<br />}</pre><br />We are only going to worry about a simple create operation since we are discussing the rules, not the testing itself. We first need to have a test case to work with:  <br /><br /><pre class="brush:groovy">class PersonDaoTest {<br /><br />    private PersonDao personDao<br /><br />    @Before void before(){<br />        personDao = new PersonDao(<br />            jdbcTemplate: null // ?<br />        )<br />    }<br />}</pre><br />Right out of the gate we run into our first hurdle... we need a <code>JdbcTempate</code> to inject. We could just connect to a database or fire up an embedded database right here and move on, but we can assume that if there is one of these tests, there will be many so a reusable solution would be best. Enter the JUnit rules. Basically, the rules are just reusable code that implements a simple interface to provide operations before and after test classes or methodes (depending on the rule annotation).<br /><br />For our first rule, we want to setup a database environment to test with.  <br /><br /><pre class="brush:groovy">class DatabaseEnvironment extends ExternalResource {<br /><br />    DataSource dataSource<br /><br />    JdbcTemplate getJdbcTemplate(){<br />        new JdbcTemplate(dataSource: dataSource)<br />    }<br /><br />    @Override<br />    protected void before() throws Throwable {<br />        Connection conn<br />        try {<br />            conn = getDataSource().getConnection()<br /><br />            final Liquibase liquibase = new Liquibase(<br />                "src/main/resources/changelog.xml",<br />                new FileSystemResourceAccessor(),<br />                new JdbcConnection( conn )<br />            )<br /><br />            liquibase.dropAll()<br />            liquibase.update( "test" )<br /><br />        } catch( ex ){<br />            fail(ex.message)<br />        } finally {<br />            conn?.close()<br />        }<br />    }<br />}</pre><br />Remember, we are assuming that you have some <code>DataSource</code> that you are using for testing. When the <code>before()</code> method is called, our database is destroyed if it exists and is then recreated to the fresh empty state. I am using liquibase for database management, but any means of creating and destroying your database would work here.  <br /><blockquote>Note: that I do not destroy the database in the <code>after()</code> method. This is intentional; it allows you to investigate the data conditions of a failed test.</blockquote>We can now integrate this into the test case and move forward:  <br /><br /><pre class="brush:groovy">class PersonDaoTest {<br /><br />    @ClassRule public DatabaseEnvironment dbEnvironment = new DatabaseEnvironment(<br />        dataSource: myTestDataSource // you must define somewhere<br />    )<br /><br />    private PersonDao personDao<br /><br />    @Before void before(){<br />        personDao = new PersonDao(<br />            jdbcTemplate: dbEnvironment.jdbcTemplate<br />        )<br />    }<br />}</pre><br />I defined the DatabaseEnvironment as a <code>@ClassRule</code> so that the database is created once for each test class, rather than for every test method. Now we can add an actual test method.  <br /><br /><pre class="brush:groovy">class PersonDaoTest {<br /><br />    @ClassRule public DatabaseEnvironment dbEnvironment = new DatabaseEnvironment(<br />        dataSource: myTestDataSource // you must define somewhere<br />    )<br /><br />    private PersonDao personDao<br /><br />    @Before void before(){<br />        personDao = new PersonDao(<br />            jdbcTemplate: dbEnvironment.jdbcTemplate<br />        )<br />    }<br /><br />    @Test void 'createPerson: simple'(){<br />        personDao.createPerson([ name:'Chris', email:'chris@stehno.com' ])<br /><br />        assert 1 == JdbcTestUtils.countRowsInTable(dbEnvironment.jdbcTemplate, 'people')<br />    }<br />}</pre><br />The test runs and passes with a fresh database every time. There is still a hidden problem here though, let's add another test method. This is a bit arbitrary but let's test the case when you add a person with no email address (successfully); we add the following test method:  <br /><br /><pre class="brush:groovy">@Test void 'createPerson: simple'(){<br />    personDao.createPerson([ name:'Chris' ])<br /><br />    assert 1 == JdbcTestUtils.countRowsInTable(dbEnvironment.jdbcTemplate, 'people')<br />}</pre><br />Now, if you run all the tests (not just the one you added), the test will fail with a value of 2 where 1 was expected. Why? The database is created and destroyed per-class, not per-test so you are working with a database that already has data in it. To get around this we could make the database work per-test, but depending on how large your schema is, this could be time consuming and greatly increase your test runtime. What we want is to clean up the existing database in-place after each test. Another <code>ExternalResource</code> rule to the rescue!  <br /><br /><pre class="brush:groovy">class DatabaseCleaner extends ExternalResource {<br /><br />    JdbcTemplate jdbcTemplate<br />    def tables = []<br /><br />    @Override<br />    protected void before() throws Throwable {<br />        tables.each { table-&gt;<br />            jdbcTemplate.execute("truncate table $table cascade")<br />        }<br />    }<br />}</pre><br />Here we have defined an <code>ExternalResource</code> rule which will truncate a specified collection of tables each time the <code>before()</code> method is called. We want to use this as an instance rule, and again, we do nothing in the <code>after()</code> method so that our data is in a known-failed state for a failed test. Our test case becomes:   <br /><br /><pre class="brush:groovy">class PersonDaoTest {<br /><br />    @ClassRule public DatabaseEnvironment dbEnvironment = new DatabaseEnvironment(<br />        dataSource: myTestDataSource // you must define somewhere<br />    )<br /><br />    @Rule public DatabaseCleaner dbCleaner = new DatabaseCleaner(<br />        jdbcTemplate: dbEnvironment.jdbcTemplate,<br />        tables:['people']<br />    )<br /><br />    private PersonDao personDao<br /><br />    @Before void before(){<br />        personDao = new PersonDao(<br />            jdbcTemplate: dbEnvironment.jdbcTemplate<br />        )<br />    }<br /><br />    @Test void 'createPerson: simple'(){<br />        personDao.createPerson([ name:'Chris', email:'chris@stehno.com' ])<br /><br />        assert 1 == JdbcTestUtils.countRowsInTable(dbEnvironment.jdbcTemplate, 'people')<br />    }<br /><br />    @Test void 'createPerson: simple'(){<br />        personDao.createPerson([ name:'Chris' ])<br /><br />        assert 1 == JdbcTestUtils.countRowsInTable(dbEnvironment.jdbcTemplate, 'people')<br />    }<br />}</pre><br />Now when we run the whole test case, we have both tests passing because before each test method, the database is cleaned in-place.<br /><br />With just these two rules we have created a stable and flexible means of testing database code. With configuration you can point your tests at an in-memory database, locally running database or shared database server.   For normal unit testing I would recommend either an embedded database, or when that is not possible a database running local to the testing machine, but those strategies will have to be discussed another time. </body></html>
