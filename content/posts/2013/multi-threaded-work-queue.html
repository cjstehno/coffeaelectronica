<!DOCTYPE html>
<html>
<head>
    <title>Multi-threaded Work Queue</title>
    <meta name="grackle.date-published" content="1/27/2013" />
    <meta name="grackle.layout" content="post" />
    <meta name="grackle.tags" content="Java,Groovy" />
    <meta name="grackle.summary" content="I finally had some time to play with the DataFlow functionality in GPars, and as you would expect, it's both simple and powerful." />
</head>
<body>
<p>I finally had some time to play with the DataFlow functionality in GPars, and as you would expect, it's both simple and powerful. I needed a simple means of processing data from a queue in a multi-threaded manner. I considered something like JMS, but for what I am working on that was too complex and too heavy. I really just needed to toss a message on a queue and let it get processed at some future time, hopefully by a couple threads. The DataFlowQueue came through perfectly.</p>

<p>Below is a simple demo:</p>

<pre>def pool = new DefaultPool(false, 3)
def queue = new DataflowQueue&lt;String&gt;()

def latch = new CountDownLatch(100)

queue.wheneverBound(new DataCallbackWithPool(pool,{msg->
 println "[${Thread.currentThread().name}] ${System.currentTimeMillis()} $msg"
 latch.countDown()
}))

100.times { n->
 queue.bind("Message-$n")
}

latch.await()</pre>

<p>The <code>DataFlowQueue</code> accepts messages that it will hand off to bound handlers. The <code>wheneverBound()</code> method will bind the handler permanently (rather than for just a single message) so that you can use the <code>DataCallbackWithPool</code> message stream as a handler. Configure the <code>DataCallbackWithPool</code> object with a pool and your actual message handler then you are done.</p>

<p>When you run the demo code you will see that the bind call returns immediately and that each message is handled on one of the three threads configured.</p>

<p>Nothing Earth-shattering, but it will come in handy. Also, since the above example was written in Groovy, you could also do this with GPars in Java, with just a few changes:</p>

<pre>Pool pool = new DefaultPool( false, 3 );
DataflowQueue&lt;String&gt; queue = new DataflowQueue&lt;&gt;();

final CountDownLatch latch = new CountDownLatch( 100 );

queue.wheneverBound( new DataCallbackWithPool( pool, new MessagingRunnable&lt;String&gt;(){
 @Override
 protected void doRun( final String msg ){
  System.out.printf( "[%s] %d%n", Thread.currentThread().getName(), System.currentTimeMillis() );
  latch.countDown();
 }
}));

for( int i=0; i&lt;100; i++){
 queue.bind( "Message-" + i );
}

latch.await();</pre>

<p>The main difference being the introduction of the MessageRunnable, since Java does not have closures yet.</p>

</body>
</html>