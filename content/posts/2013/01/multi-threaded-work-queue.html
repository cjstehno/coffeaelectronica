
<html><head>
<title>Multi-threaded Work Queue</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2013-01-27T07:41:00.000-06:00" />
</head><body>I finally had some time to play with the DataFlow functionality in GPars, and as you would expect, it's both simple and powerful.  I needed a simple means of processing data from a queue in a multi-threaded manner. I considered something like JMS, but for what I am working on that was too complex and too heavy. I really just needed to toss a message on a queue and let it get processed at some future time, hopefully by a couple threads.  The DataFlowQueue came through perfectly.<br /><a name='more'></a>Below is a simple demo:  <br /><br /><pre class="brush:groovy">def pool = new DefaultPool(false, 3)<br />def queue = new DataflowQueue&lt;String&gt;()<br /><br />def latch = new CountDownLatch(100)<br /><br />queue.wheneverBound(new DataCallbackWithPool(pool,{msg-&gt;<br /> println "[${Thread.currentThread().name}] ${System.currentTimeMillis()} $msg"<br /> latch.countDown()<br />}))<br /><br />100.times { n-&gt;<br /> queue.bind("Message-$n")<br />}<br /><br />latch.await()<br /></pre><br />The DataFlowQueue accepts messages that it will hand off to bound handlers. The "wheneverBound" method will bind the handler permanently (rather than for just a single message) so that you can use the DataCallbackWithPool message stream as a handler.  Configure the DataCallbackWithPool object with a pool and your actual message handler then you are done.<br /><br />When you run the demo code you will see that the bind call returns immediately and that each message is handled on one of the three threads configured.<br /><br />Nothing Earth-shattering, but it will come in handy.  Also, since the above example was written in Groovy, you could also do this with GPars in Java, with just a few changes:  <br /><br /><pre class="brush:java">Pool pool = new DefaultPool( false, 3 );<br />DataflowQueue&lt;String&gt; queue = new DataflowQueue&lt;&gt;();<br /><br />final CountDownLatch latch = new CountDownLatch( 100 );<br /><br />queue.wheneverBound( new DataCallbackWithPool( pool, new MessagingRunnable&lt;String&gt;(){<br /> @Override<br /> protected void doRun( final String msg ){<br />  System.out.printf( "[%s] %d%n", Thread.currentThread().getName(), System.currentTimeMillis() );<br />  latch.countDown();<br /> }<br />}));<br /><br />for( int i=0; i&lt;100; i++){<br /> queue.bind( "Message-" + i );<br />}<br /><br />latch.await();<br /></pre> The main difference being the introduction of the MessageRunnable, since Java does not have closures yet.</body></html>
