
<html><head>
<title>Mocking Objects With Non-Empty Constructors</title>
<meta name="grackle.layout" content="post" />
<meta name="grackle.date-published" content="2007-09-20T11:43:00.000-05:00" />
</head><body>While writing mock objects with <a href="http://jmock.org/">JMock</a>, I have run into a reoccurring issue, you cannot mock concrete classes that do not have an empty constructor (this has been addressed by the JMock development team; however, the specific code line has not yet been released). Sometimes, for one reason or another, you have neither an interface nor empty constructor to mock an object with.<br /><a name='more'></a> The way JMock creates its proxied mock objects is "on creation", meaning that when you create the mock, the proxy object is created and stored, thereby not allowing you any way to specify constructor arguments.  With a little extension to the mocking API you can still mock those classes. The solution is a simple extension of the <a href="http://cglib.sourceforge.net/">CGLIB</a>-based functionality that is already there such that the proxy is created only when the <tt>proxy()</tt> method is called. The code of the two classes needed is shown below:  <br /><br /><pre class="brush:java">public class CGLIBCoreLazyMock extends AbstractDynamicMock implements MethodInterceptor {<br /><br />        private Enhancer enhancer;<br />        private Class[] argTypes;<br />        private Object[] args;<br />        private Object proxy;<br /><br />        public CGLIBCoreLazyMock(Class mockedType,Class[] argTypes,Object[] args){<br />   super(<br />    mockedType,<br />    mockNameFromClass(mockedType),<br />    new LIFOInvocationDispatcher()<br />   );<br />   this.argTypes = argTypes;<br />   this.args = args;<br />   this.enhancer = new Enhancer();<br />   enhancer.setSuperclass(mockedType);<br />   enhancer.setCallback(this);<br />        }<br /><br />        public Object proxy() {<br />   if(proxy == null){<br />    this.proxy = enhancer.create(argTypes,args);<br />   }<br />   return(proxy);<br />        }<br /><br />        public Object intercept(Object thisProxy, Method method,<br />   Object[] args, MethodProxy superProxy ) throws Throwable {<br />   return mockInvocation(new Invocation(proxy,method,args));<br />        }<br />}</pre><br />and then a Mock extension.   <br /><br /><pre class="brush:java">public class LazyMock extends org.jmock.Mock {<br />    public LazyMock(Class mockedType,Class[] argTypes,Object[] args){<br />        super(new CGLIBCoreLazyMock(mockedType,argTypes,args));<br />    }<br />}</pre><br />By adding this functionality to JMock, you can mock these classes and still use all of the stub and expectation features that JMock provides. My first resolution to this problem was a quick custom hack using CGLIB. As it threatened to get more complex, I took a peek at the JMock source and found that it would not be hard to implement.  I guess I could have gotten the source and added it directly to their code base, and I even looked at doing that right off, but their project was Ant-based and seemed to be missing some of the pieces required for the build. I just made a little extension jar and it seems to work well enough.  <br /><blockquote><b>Update:</b> <a href="http://jmock.org/">JMock 2</a> fixes this issue internally and has a lot of other improvements. See <a href="http://www.coffeaelectronica.com/2007/09/are-you-still-mocking-me.html">Are You Still Mocking Me?</a> for updated information.</blockquote></body></html>
