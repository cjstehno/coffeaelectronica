<html>
<head>
    <title>Are You Still Mocking Me?</title>
    <meta name="grackle.layout" content="post"/>
    <meta name="grackle.date-published" content="2007-09-20T19:08:00.000-05:00"/>
</head>
<body><a href="http://jmock.org/">JMock 2</a> came out not too long ago and after some initial worry about backwards
compatibility I decided to give it a try. It plays very nicely with version one, but you will want to run out and
convert all of your tests once you see how truly beautiful version two is. A few years ago, I wrote a brief article on
unit testing with JMock called "<a href="http://www.coffeaelectronica.com/2006/09/are-you-mocking-me.html">Are You
    Mocking Me?</a>". I would like to showcase some of the new goodies in version two by revisiting that article and
converting the examples to the newer version. <br/><a name='more'></a>You should at least skim the other article to get
a feel for the example at hand as I will be covering mocking differences, not the original issue of mock testing. In the
example, our test was written as an extension of <tt>MockObjectTestCase</tt>, this is still the case (pardon the pun),
except that the package is different, we are now using the <tt>org.jmock.integration.junit3.MockObjectTestCase</tt>
class from version two. It serves basically the same purpose, to provide some helper methods. Our our original test case
was: <br/><br/>
<pre class="brush:java">public class HelloTagTest extends MockObjectTestCase {<br/> public void testHello() throws Exception {<br/>  Mock mockPageCtx = new Mock(PageContext.class);<br/><br/>  HelloTag helloTag = new HelloTag();<br/>  helloTag.setPageContext((PageContext)mockPageCtx.proxy());<br/><br/>  assertEquals("Hello, Mr. Anderson!",helloTag.buildOutput());<br/> }<br/>}</pre>
<br/>which, when updated will become: <br/><br/>
<pre class="brush:java">public class HelloTagTest extends MockObjectTestCase {<br/><br/>    public void testHello() throws Exception {<br/>        final PageContext pageCtx = mock(PageContext.class);<br/><br/>        final HelloTag helloTag = new HelloTag();<br/>        helloTag.setPageContext(pageCtx);<br/><br/>        assertEquals("Hello, Mr. Anderson!"),helloTag.buildOutput());<br/>    }<br/>}</pre>
<br/>The difference is subtle but very interesting. Now instead of a <tt>Mock</tt> object, we have an instance of the
object that was mocked and we no longer need to call the <tt>proxy()</tt> method and do the casting. The second example
adds a stubbed method, which after using JMock for a while I realized was not such a great thing, since it does not
really verify that it was called, just that it can be called. <br/><br/>
<pre class="brush:java">public class HelloTagTest extends MockObjectTestCase {<br/> public void testHello() throws Exception {<br/>  Mock mockPageCtx = new Mock(PageContext.class);<br/>  mockPageCtx.stubs().method("findAttribute").with(eq("foo")).will(returnValue("Mr. Anderson"));<br/><br/>  HelloTag helloTag = new HelloTag();<br/>  helloTag.setPageContext((PageContext)mockPageCtx.proxy());<br/><br/>  assertEquals("Hello, Mr. Anderson!",helloTag.buildOutput());<br/> }<br/>}</pre>
<br/>The new version both takes care of that omission and updates the code to use the new expectation definition method:
<br/><br/>
<pre class="brush:java">public class HelloTagTest extends MockObjectTestCase {<br/><br/>    public void testHello() throws Exception {<br/>  final PageContext pageCtx = mock(PageContext.class);<br/>  checking(new Expectations(){<br/>     {<br/>    one(pageCtx).findAttribute("foo"); will(returnValue("Mr. Anderson"));<br/>   }<br/>  });<br/><br/>  final HelloTag helloTag = new HelloTag();<br/>  helloTag.setPageContext(pageCtx);<br/><br/>  assertEquals("Hello, Mr. Anderson!"),helloTag.buildOutput());<br/>    }<br/>}</pre>
<br/>Now, the first time I saw the code in the checking method, I had to double check that I was looking at a Java
example. Basically you are creating an anonymous extension of the <tt>Expectations</tt> class and then adding an
instance initializer to it (the inner curly braces) to provide the expectations themselves. Notice that the method is
actually being called on the mocked object; it's not a string, which means that refactoring will not break your mock
tests. If you have never run into that problem with version one, count yourself lucky. Okay, I am going to jump down to
the final code to finish up: <br/><br/>
<pre class="brush:java">public class HelloTagTest extends MockObjectTestCase {<br/> public void testHello() throws Exception {<br/>  Mock mockJspWriter = new Mock(JspWriterMockAdapter.class);<br/>  mockJspWriter.expects(once()).method("print")<br/>    .with(eq("Hello, Mr. Anderson!"));<br/><br/>  Mock mockPageCtx = new Mock(PageContext.class);<br/>  mockPageCtx.stubs().method("findAttribute").with(eq("matrix"))<br/>    .will(returnValue("Mr. Anderson"));<br/>  mockPageCtx.stubs().method("getOut").withNoParameters()<br/>    .will(returnValue((JspWriter)mockJspWriter.proxy()));<br/><br/>  HelloTag helloTag = new HelloTag();<br/>  helloTag.setPageContext((PageContext)mockPageCtx.proxy());<br/>  helloTag.setId("matrix");<br/>  helloTag.doStartTag();<br/>  helloTag.doEndTag();<br/><br/>  assertEquals("Hello, Mr. Anderson!",helloTag.buildOutput());<br/><br/>  mockJspWriter.verify();<br/> }<br/>}</pre>
<br/>With version two you can mock objects that do not have an empty constructor, though you have to set a non-default
"Imposterizer". This negates the need for the adapter class defined in the old article. <br/><br/>
<pre class="brush:java">public class HelloTagTest extends MockObjectTestCase {<br/><br/> public HelloTagTest(){<br/>        setImposterizer(ClassImposterizer.INSTANCE);<br/>    }<br/><br/>    public void testHello() throws Exception {<br/>        final JspWriter jspWriter = mock(JspWriter.class);<br/>        checking(new Expectations(){<br/>            {<br/>                one(jspWriter).print("Hello, Mr. Anderson!");<br/>            }<br/>        });<br/><br/>        final PageContext pageCtx = mock(PageContext.class);<br/>        checking(new Expectations(){<br/>            {<br/>                one(pageCtx).findAttribute("martix"); will(returnValue("Mr. Anderson"));<br/>                one(pageCtx).getOut(); will(returnValue(jspWriter));<br/>            }<br/>        });<br/><br/>        final HelloTag helloTag = new HelloTag();<br/>        helloTag.setPageContext(pageCtx);<br/>        helloTag.setId("matrix");<br/>        helloTag.doStartTag();<br/>        helloTag.doEndTag();<br/><br/>        assertEquals("Hello, Mr. Anderson!"),helloTag.buildOutput());<br/>    }<br/>}</pre>
<br/>You can't tell me that is not cleaner and more straight-forward. You could actually collapse the
<tt>checking()</tt> methods into one if you wanted to. I tend to group them like the example above since it can often
reveal common blocks of code that can be extracted into separate shared methods. The is a lot more to discuss with JMock
but this gives you a good overview based on old version one code.
</body>
</html>
