<html>
<head>
    <title>Tour de Mock 5: Groovy</title>
    <meta name="grackle.layout" content="post"/>
    <meta name="grackle.date-published" content="2010-10-29T11:21:00.000-05:00"/>
</head>
<body>I decided to add another post to my series of mocking comparisons. I have been working a lot with <a
        href="http://groovy.codehaus.org/">Groovy</a> and felt that it would make an interesting addition considering
the language provides a rich mocking ability without any additional libraries required.<br/><a name='more'></a> The
@Before method shows the flexibility of Groovy right away with the mocking of the service interface as well as the
ServletContext and ServletConfig interfaces: <br/><br/>
<pre class="brush:groovy">@Before<br/>void before(){<br/> emailListService = [<br/>  getListByName:{ name-&gt;<br/>   if( 'foolist' == name ){ return LIST }<br/>   throw new IOException()<br/>  }<br/> ] as EmailListService<br/><br/> def servletContext = [<br/>  getAttribute:{ key-&gt;<br/>   assertEquals EmailListService.KEY, key<br/>   emailListService<br/>  }<br/> ] as ServletContext<br/><br/> def servletConfig = [ getServletContext:{servletContext} ] as ServletConfig<br/><br/> emailListServlet = new EmailListServlet()<br/> emailListServlet.init servletConfig<br/>}<br/></pre>
<br/>Groovy allows you to take a map of closures keyed with the method name and cast it as an instance of an interface,
basically built-in mocking. The first test is where we test the doGet method with no listName parameter: <br/><br/>
<pre class="brush:groovy">@Test(expected=IOException.class)<br/>void doGet_without_list(){<br/> def request = [<br/>  getParameter:{ pname-&gt;<br/>   assertEquals 'listName', pname<br/>   null<br/>  }<br/> ] as HttpServletRequest<br/><br/> emailListServlet.doGet request, [] as HttpServletResponse<br/>}<br/></pre>
<br/>If you don't use Groovy much, these mocked instances may seem less readable than some of the other mocking APIs;
however, with a little practice you can really see the broad scope of mocking capabilities it has. The test with
listName data shows a successful result: <br/><br/>
<pre class="brush:groovy">@Test<br/>void doGet_with_list(){<br/> def request = [<br/>  getParameter:{ pname-&gt;<br/>   assertEquals 'listName', pname<br/>   'foolist'<br/>  }<br/> ] as HttpServletRequest<br/><br/> def outcalls = [].addAll( LIST )<br/> PrintWriter.metaClass.println = { out-&gt; assertEquals outcalls.remove(0), out }<br/><br/> def response = [ getWriter:{ new PrintWriter(new StringWriter()) } ] as HttpServletResponse<br/><br/> emailListServlet.doGet request, response<br/>}<br/></pre>
<br/>where we can also see the generally tricking mocking of the PrintWriter and its ordered sequence of calls. In this
case you are working with simple code rather than any additional API functionality. The list of expected email strings
is provided in the order they are to be called and the mock PrintWriter verifies that the current call is the same as
the next expected value. The whole test case is shown below: <br/><br/>
<pre class="brush:groovy">package com.stehno.mockery;<br/><br/>import javax.servlet.ServletConfig;<br/>import javax.servlet.ServletContext;<br/>import javax.servlet.http.HttpServletRequest<br/>import javax.servlet.http.HttpServletResponse<br/><br/>import static junit.framework.Assert.*<br/><br/>import org.junit.After<br/>import org.junit.Test<br/>import org.junit.Before;<br/><br/>import com.stehno.mockery.service.EmailListService;<br/><br/>class EmailListServlet_GroovyMockTest {<br/><br/> private def LIST = ['larry@stooge.com','moe@stooge.com','curley@stooge.com']<br/> private def emailListServlet<br/> private def emailListService<br/><br/> @Before<br/> void before(){<br/>  emailListService = [<br/>   getListByName:{ name-&gt;<br/>    if( 'foolist' == name ){ return LIST }<br/>    throw new IOException()<br/>   }<br/>  ] as EmailListService<br/><br/>  def servletContext = [<br/>   getAttribute:{ key-&gt;<br/>    assertEquals EmailListService.KEY, key<br/>    emailListService<br/>   }<br/>  ] as ServletContext<br/><br/>  def servletConfig = [ getServletContext:{servletContext} ] as ServletConfig<br/><br/>  emailListServlet = new EmailListServlet()<br/>  emailListServlet.init servletConfig<br/> }<br/><br/> @Test(expected=IOException.class)<br/> void doGet_without_list(){<br/>  def request = [<br/>   getParameter:{ pname-&gt;<br/>    assertEquals 'listName', pname<br/>    null<br/>   }<br/>  ] as HttpServletRequest<br/><br/>  emailListServlet.doGet request, [] as HttpServletResponse<br/> }<br/><br/> @Test<br/> void doGet_with_list(){<br/>  def request = [<br/>   getParameter:{ pname-&gt;<br/>    assertEquals 'listName', pname<br/>    'foolist'<br/>   }<br/>  ] as HttpServletRequest<br/><br/>  def outcalls = [].addAll( LIST )<br/>  PrintWriter.metaClass.println = { out-&gt; assertEquals outcalls.remove(0), out }<br/><br/>  def response = [ getWriter:{ new PrintWriter(new StringWriter()) } ] as HttpServletResponse<br/><br/>  emailListServlet.doGet request, response<br/> }<br/><br/> @After<br/> void after(){<br/>  emailListServlet = null<br/>  emailListService = null<br/> }<br/>}<br/></pre>
<br/>I found Groovy to be a very useful mocking tool and would recommend it, especially if you are already using Groovy
in your project. Beyond this basic functionality there are also some mocking APIs written for Groovy that add additional
features or provide simpler mocking capabilities. <br/>
<blockquote>You can find the source code used in this posting in my <a
        href="http://github.com/cjstehno/coffeaelectronica/tree/master/tourdemock">TourDeMock</a> project.
</blockquote>
</body>
</html>
