<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>CoffeaElectronica.com</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Christopher J. Stehno">
    <meta name="keywords" content="java,groovy,blog">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/asciidoctor.css" rel="stylesheet">
    <link href="/css/base.css" rel="stylesheet">
    <link href="/css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="shortcut icon" href="/favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
   

		<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">CoffeaElectronica.com</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="/index.html">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="/archive.html">Archive</a></li>
            
             <li role="presentation" class="dropdown">
	      <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-expanded="false">
		Tags <span class="caret"></span>
	      </a>
	      <ul class="dropdown-menu" role="menu">
		
		  <li><a href="/tags/ant.html">ant</a></li>
		
		  <li><a href="/tags/blog.html">blog</a></li>
		
		  <li><a href="/tags/gradle.html">gradle</a></li>
		
		  <li><a href="/tags/groovy.html">groovy</a></li>
		
		  <li><a href="/tags/java.html">java</a></li>
		
		  <li><a href="/tags/javascript.html">javascript</a></li>
		
		  <li><a href="/tags/maven.html">maven</a></li>
		
		  <li><a href="/tags/python.html">python</a></li>
		
		  <li><a href="/tags/spring.html">spring</a></li>
		
		  <li><a href="/tags/testing.html">testing</a></li>
		
		
	      </ul>
	    </li>
            
            <li><a href="/feed.xml">Subscribe</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
    


	
		<a href="blog/2015/secure-rest-spring.html"><h1>Secure REST in Spring</h1></a>
		<p><em>04 May 2015</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/groovy.html'>groovy</a></p>
		<p><p>Getting HTTPS to play nice with REST and non-browser web clients in development (with a self-signed certificate) can be a frustrating effort. I struggled for a while down the path of using the Spring <code>RestTemplate</code> thinking that since I was using Spring MVC as my REST provider, it would make things easier; in this case, Spring did not come to the rescue, but Groovy did or rather the Groovy <a href="https://github.com/jgritman/httpbuilder">HTTPBuilder</a> did.</p><p>To keep this discussion simple, we need a simple REST project using HTTPS. I found the <a href="https://github.com/spring-guides/gs-rest-service">Spring REST Service Guide</a> project useful for this (with a few modifications to follow).</p><p>Go ahead and clone the project:</p>
<pre><code>git clone git@github.com:spring-guides/gs-rest-service.git
</code></pre><p>Since this is a tutorial project, it has a few versions of the code in it. We are going to work with the "complete" version, which is a Gradle project. Let's go ahead and do a build and run just to ensure everything works out of the box:</p>
<pre><code>cd gs-rest-service/complete
./gradlew bootRun
</code></pre><p>After a bunch of downloading and startup logging you should see that the application has started. You can give it a test by opening <code>http://localhost:8080/greeting?name=Chris</code> in your browser, which should respond with:</p>
<pre><code class="json">{
    &quot;id&quot;: 2,
    &quot;content&quot;: &quot;Hello, Chris!&quot;
}
</code></pre><p>Now that we have that running, we want a RESTful client to call it rather that hitting it using the browser. Let's get it working with the simple HTTP case first to ensure that we have everything working before we go into the HTTPS configuration. Create a groovy script, <code>rest-client.groovy</code> with the following content:</p>
<pre><code class="groovy">@Grapes(
    @Grab(group=&#39;org.codehaus.groovy.modules.http-builder&#39;, module=&#39;http-builder&#39;, version=&#39;0.7.1&#39;)
)

import groovyx.net.http.HTTPBuilder
import static groovyx.net.http.Method.GET

def http = new HTTPBuilder( &#39;http://localhost:8080/&#39; )

http.get( path: &#39;greeting&#39;, query:[name:&#39;Chris&#39;] ) { resp, json -&gt;
    println &quot;Status: ${resp.status}&quot;
    println &quot;Content: $json&quot;
}
</code></pre><p>Since this is not a discussion of HTTPBuilder itself, I will leave most of the details to your own research; however, it's pretty straight forward. We are making the same request we made in the browser, and after another initial batch of dependency downloads (grapes) it should yield:</p>
<pre><code>Status: 200
Content: [content:Hello, Chris!, id:6]
</code></pre><p>Ok, our control group is working. Now, let's add in the HTTPS. For the Spring Boot project, it's pretty trivial. We need to add an <code>application.properties</code> file in <code>src/main/resources</code> with the following content:</p>
<pre><code>server.port = 8443
server.ssl.key-store = /home/cjstehno/.keystore
server.ssl.key-store-password = tomcat
server.ssl.key-password = tomcat
</code></pre><p>Of course, update the key-store path to your home directory. For the server, we also need to install a certificate for our use. </p>
<blockquote><p>I am not a security certificate expert, so from here on out I will state that this stuff works in development but I make no claims that this is suitable for production use. Proceed at your own risk!</p>
</blockquote><p>From the <a href="http://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html">Tomcat 8 SSL How To</a>, run the <code>keytool -genkey -alias tomcat -keyalg RSA</code> and run through the questions answering everything with 'localhost' (there seems to be a reason for this).</p><p>At this point you should be able to restart the server and hit it via HTTPS (<a href="https://localhost:8443/greeting?name=Chris">https://localhost:8443/greeting?name=Chris</a>) to retrieve a successful response as before, though you will need to accept the self-signed certificate.</p><p>Now try the client. Update the URL to the new HTTPS version:</p>
<pre><code>def http = new HTTPBuilder( &#39;https://localhost:8443/&#39; )
</code></pre><p>and give it a run. You should see something like:</p>
<pre><code>Caught: javax.net.ssl.SSLPeerUnverifiedException: peer not authenticated
javax.net.ssl.SSLPeerUnverifiedException: peer not authenticated
</code></pre><p>I will start with the simplest method of resolving this problem. HTTPBuilder provides a configuration method that will just ignore these types of SSL errors. If you add:</p>
<pre><code>http.ignoreSSLIssues()
</code></pre><p>before you make a request, it will succeed as normal. This should be used only as a development configuration, but there are times when you just want to get something workign for testing. If that's all you want here, you're done. From here on out I will show how to get the SSL configuration working for a more formal use case.</p><p>Still with me? Alright, let's have fun with certificates! The <a href="https://github.com/jgritman/httpbuilder/wiki/SSL">HTTPBuilder wiki page for SSL</a> gives us most of what we need. To summarize, we need to export our server certificate and then import it into a keyfile that our client can use. To export the server certificate, run:</p>
<pre><code>keytool -exportcert -alias &quot;tomcat&quot; -file mytomcat.crt -keystore ~/.keystore -storepass tomcat
</code></pre><p>which will export the "tomcat" certificate from the keystore at "~/.keystore" (the one we created earlier) and save it into "mytomcat.crt". Next, we need to import this certificate into the keystore that will be used by our client as follows:</p>
<pre><code>keytool -importcert -alias &quot;tomcat&quot; -file mytomcat.crt -keystore clientstore.jks -storepass clientpass
</code></pre><p>You will be asked to trust this certificate, which you should answer "yes" to continue.</p><p>Now that we have our certificate ready, we can update the client script to use it. The client script becomes:</p>
<pre><code class="groovy">@Grapes(
    @Grab(group=&#39;org.codehaus.groovy.modules.http-builder&#39;, module=&#39;http-builder&#39;, version=&#39;0.7.1&#39;)
)

import groovyx.net.http.HTTPBuilder
import static groovyx.net.http.Method.GET
import java.security.KeyStore
import org.apache.http.conn.scheme.Scheme
import org.apache.http.conn.ssl.SSLSocketFactory

def http = new HTTPBuilder( &#39;https://localhost:8443/&#39; )

def keyStore = KeyStore.getInstance( KeyStore.defaultType )

new File( args[0] ).withInputStream {
   keyStore.load( it, args[1].toCharArray() )
}

http.client.connectionManager.schemeRegistry.register(new Scheme(&quot;https&quot;, new SSLSocketFactory(keyStore), 443) )

http.get( path: &#39;greeting&#39;, query:[name:&#39;Chris&#39;] ) { resp, json -&gt;
    println &quot;Status: ${resp.status}&quot;
    println &quot;Content: $json&quot;
}
</code></pre><p>The main changes from the previous version are the loading and use of the keystore by the connection manager. When you run this version of the script, with:</p>
<pre><code>groovy rest-client.groovy clientstore.jks clientpass
</code></pre><p>you get:</p>
<pre><code>Status: 200
Content: [content:Hello, Chris!, id:1]
</code></pre><p>We are now using HTTPS on both the server and client for our rest service. It's not all that bad to setup once you figure out the steps, but in general the information seems to be tough to find.</p></p>
  	
		<a href="blog/2015/tour-de-mock-6-spock.html"><h1>Tour de Mock 6: Spock</h1></a>
		<p><em>09 April 2015</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/groovy.html'>groovy</a>, <a href='/tags/testing.html'>testing</a></p>
		<p><p>My last entry in my "Tour de Mock" series was focused on basic <a href="http://coffeaelectronica.com/blog/2010/tour-de-mock-5.html">Groovy mocking</a>. In this post, I am going to take a look at the <a href="https://code.google.com/p/spock/">Spock Framework</a>, which is an alternative testing framework with a lot of features, including its own mocking API.</p><p>Since it's been a while, let's refer back to the <a href="http://coffeaelectronica.com/blog/2009/tour-de-mock-1.html">original posting</a> as a refresher of what is being tested. We have a <code>Servlet</code>, the <code>EmailListServlet</code> </p>
<pre><code class="groovy">public class EmailListServlet extends HttpServlet {

    private EmailListService emailListService;

    public void init() throws ServletException {
        final ServletContext servletContext = getServletContext();
        this.emailListService = (EmailListService)servletContext.getAttribute(EmailListService.KEY);

        if(emailListService == null) throw new ServletException(&quot;No ListService available!&quot;);
    }

    protected void doGet(final HttpServletRequest req, final HttpServletResponse res) throws ServletException, IOException {
        final String listName = req.getParameter(&quot;listName&quot;);
        final List&lt;String&gt; list = emailListService.getListByName(listName);
        PrintWriter writer = null;
        try {
            writer = res.getWriter();
            for(final String email : list){
                writer.println(email);
            }
        } finally {
            if(writer != null) writer.close();
        }
    }
}
</code></pre><p>which uses an <code>EmailListService</code></p>
<pre><code class="groovy">public interface EmailListService {

    public static final String KEY = &quot;com.stehno.mockery.service.EmailListService&quot;;

    /**
     * Retrieves the list of email addresses with the specified name. If no list
     * exists with that name an IOException is thrown.
     */
    List&lt;String&gt; getListByName(String listName) throws IOException;
}
</code></pre><p>to retrieve lists of email addresses, because that's what you do, right? It's just an example. :-)</p><p>First, we need to add Spock to our build (recently converted to Gradle, but basically the same) by adding the following line to the <code>build.gradle</code> file:</p>
<pre><code>testCompile &quot;org.spockframework:spock-core:1.0-groovy-2.4&quot;
</code></pre><p>Next, we need a test class. Spock uses the concept of a test "Specification" so we create a simple test class as:</p>
<pre><code class="groovy">class EmailListServlet_SpockSpec extends Specification {
    // test stuff here...
}
</code></pre><p>Not all that different from a JUnit test; conceptually they are very similar.</p><p>Just as in the other examples of testing this system, we need to setup our mock objects for the servlet environment and other collaborators:</p>
<pre><code class="groovy">def setup() {
    def emailListService = Mock(EmailListService) {
        _ * getListByName(null) &gt;&gt; { throw new IOException() }
        _ * getListByName(&#39;foolist&#39;) &gt;&gt; LIST
    }

    def servletContext = Mock(ServletContext) {
        1 * getAttribute(EmailListService.KEY) &gt;&gt; emailListService
    }

    def servletConfig = Mock(ServletConfig) {
        1 * getServletContext() &gt;&gt; servletContext
    }

    emailListServlet = new EmailListServlet()
    emailListServlet.init servletConfig

    request = Mock(HttpServletRequest)
    response = Mock(HttpServletResponse)
}
</code></pre><p>Spock provides a <code>setup</code> method that you can override to perform your test setup operations, such as mocking. In this example, we are mocking the service interface, and the servlet API interfaces so that they behave in the deisred manner.</p><p>The mocking provided by Spock took a little getting used to when coming from a primarily mockito-based background, but once you grasp the overall syntax, it's actually pretty expressive. In the code above for the <code>EmailListService</code>, I am mocking the <code>getListByName(String)</code> method such that it will accept any number of calls with a <code>null</code> parameter and throw an exception, as well as any number of calls with a <code>foolist</code> parameter which will return a reference to the email address list. Similarly, you can specify that you expect only N calls to a method as was done in the other mocks. You can dig a little deeper into the mocking part of the framework in the <a href="http://spockframework.github.io/spock/docs/1.0/interaction_based_testing.html">Interaction-based Testing</a> section of the Spock documentation.</p><p>Now that we have our basic mocks ready, we can test something. As in the earlier examples, we want to test the condition when no list name is specified and ensure that we get the expected <code>Exception</code> thrown:</p>
<pre><code class="groovy">def &#39;doGet: without list&#39;() {
    setup:
    1 * request.getParameter(&#39;listName&#39;) &gt;&gt; null

    when:
    emailListServlet.doGet request, response

    then:
    thrown(IOException)
}
</code></pre><p>One thing you should notice right away is that Spock uses label blocks to denote different parts of a test method. Here, the <code>setup</code> block is where we do any additional mocking or setup specific to this test method. The <code>when</code> block is where the actual operations being tested are performed while the <code>then</code> block is where the results are verified and conditions examined.</p><p>In our case, we need to mock out the reuest parameter to return <code>null</code> and then we need to ensure that an <code>IOException</code> is thrown.</p><p>Our other test is the case when a valid list name is provided:</p>
<pre><code class="groovy">def &#39;doGet: with list&#39;() {
    setup:
    1 * request.getParameter(&#39;listName&#39;) &gt;&gt; &#39;foolist&#39;

    def writer = Mock(PrintWriter)

    1 * response.getWriter() &gt;&gt; writer

    when:
    emailListServlet.doGet request, response

    then:
    1 * writer.println(LIST[0])
    1 * writer.println(LIST[1])
    1 * writer.println(LIST[2])
}
</code></pre><p>In the <code>then</code> block here, we verify that the <code>println(String)</code> method of the mocked <code>PrintWriter</code> is called with the correct arguments in the correct order.</p><p>Overall, Spock is a pretty clean and expressive framework for testing and mocking. It actually has quite a few other interesting features that beg to be explored.</p>
<blockquote><p>You can find the source code used in this posting in my <a href="http://github.com/cjstehno/coffeaelectronica/tree/master/tourdemock">TourDeMock</a> project.</p>
</blockquote></p>
  	
		<a href="blog/2015/ast-testing.html"><h1>Testing AST Transformations</h1></a>
		<p><em>08 March 2015</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/groovy.html'>groovy</a>, <a href='/tags/testing.html'>testing</a></p>
		<p><p>While working on my <a href="https://github.com/cjstehno/effigy">Effigy</a> project, I have gone deep into the world of Groovy AST Transformations and found that they are, in my opinion, the most interesting and useful feature of the Groovy language; however, developing them is a bit of a poorly-documented black art, especially around writing unit tests for your transformations. Since the code you are writing is run at compile-time, you generally have little access or view to what is going on at that point and it can be quite frustrating to try and figure out why something is failing.</p><p>After some Googling and experimentation, I have been able to piece together a good method for testing your transformation code, and it's actually not all that hard. Also, you can do your development and testing in a single project, rather than in a main project and testing project (to account for the need to compile the code for testing)</p><p>The key to making transforms testable is the <code>GroovyClassLoader</code> which gives you the ability to compile Groovy code on the fly:</p>
<pre><code>def clazz = new GroovyClassLoader().parseClass(sourceCode)
</code></pre><p>During that <code>parseClass</code> method is when all the AST magic happens. This means you can not only easily test your code, but also debug into your transformations to get a better feel for what is going wrong when things break - and they often do.</p><p>For my testing, I have started building a <code>ClassBuilder</code> code helper that is a shell for String-based source code. You provide a code template that acts as your class shell, and then you inject code for your specific test case. You end up with a reasonably clean means of building test code and instantiating it:</p>
<pre><code class="groovy">private final ClassBuilder code = forCode(&#39;&#39;&#39;
    package testing

    import com.stehno.ast.annotation.Counted

    class CountingTester {
        $code
    }
&#39;&#39;&#39;)

@Test void &#39;single method&#39;(){
    def instance = code.inject(&#39;&#39;&#39;
        @Counted
        String sayHello(String name){
            &quot;Hello, $name&quot;
        }
    &#39;&#39;&#39;).instantiate()

    assert instance.sayHello(&#39;AST&#39;) == &#39;Hello, AST&#39;
    assert instance.getSayHelloCount() == 1

    assert instance.sayHello(&#39;Counting&#39;) == &#39;Hello, Counting&#39;
    assert instance.getSayHelloCount() == 2
}
</code></pre><p>The <code>forCode</code> method creates the builder and prepares the code shell. This construct may be reused for each of your tests.</p><p>The <code>inject</code> method adds in the actual code you care about, meaning your transformation code being tested.</p><p>The <code>instantiate</code> method uses the <code>GroovyClassLoader</code> internally to load the class and then instantiate it for testing.</p><p>I am going to add a version of the <code>ClassBuilder</code> to my <a href="https://github.com/cjstehno/vanilla">Vanilla</a> project once it is more stable; however, I have a version of it and a simple AST testing demo project in the <a href="https://github.com/cjstehno/coffeaelectronica/tree/master/ast-testing">ast-testing</a> CoffeaElectronica sub-repo. This sample code builds a simple AST Transformation for counting method invocations and writes normal unit tests for it (the code above is taken from one of the tests).</p>
<blockquote><p>Note: I have recently discovered the <a href="http://docs.groovy-lang.org/latest/html/gapi/org/codehaus/groovy/tools/ast/TransformTestHelper.html">groovy.tools.ast.TransformTestHelper</a> class; I have not yet tried it out, but it seems to provide a similar base functionality set to what I have described here.</p>
</blockquote></p>
  	
		<a href="blog/2015/custom-github-hosting.html"><h1>Custom Domain for GitHub Pages</h1></a>
		<p><em>15 February 2015</em> ~ <a href='/tags/blog.html'>blog</a></p>
		<p><p>I have been working for a while now to get my blog fully cut over to being generated by <a href="http://jbake.org/">JBake</a> and hosted on <a href="http://github.org">GitHub</a>; it's not all that difficult, just a format conversion and some domain fiddling, but I was procrastinating.</p><p>Pointing your GitHub Pages at a custom domain is not all that hard to do, and they provide <a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/">decent documentation</a> about how to do it; however, some streamlining is nice for DNS novices like myself. I may have done things a bit out of order, but it worked in the end...</p><p>First, I created <code>A</code> records for the GitHub-provided IP Addresses. I use Godaddy for my domain names, so your experience may be a bit different; but, in the Godaddy DNS Zone File editor you end up adding something like:</p><p><img src="/files/a_records.png" alt="A Record""/></p><p>Next, I added a <code>CName</code> record alias for <code>www</code> pointing to my GitHub account hostname, which ended up looking like this:</p><p><img src="/files/cname_record.png" alt="CName Record""/></p><p>Lastly, you need to make <a href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/">changes in your repository</a> - this step seems to be missed by a lot of people. The gist of it is that you add a new file to your <code>gh-pages</code> branch, named <code>CNAME</code> (all caps, no extension). And in that file you add your domain name (without <code>http://www.</code>). Save the file and be sure you push it to your remote repository.</p><p>At this point it worked for me, but the documentation said it could take up to 48 hours to propagate the changes.</p></p>
  	
		<a href="blog/2014/gradle-and-codenarc.html"><h1>Gradle and CodeNarc</h1></a>
		<p><em>07 November 2014</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/java.html'>java</a>, <a href='/tags/testing.html'>testing</a>, <a href='/tags/gradle.html'>gradle</a>, <a href='/tags/groovy.html'>groovy</a></p>
		<p><p>The subject of "code quality tools" has lead to many developer holy wars over the years, so I'm not really going to touch the subject of their value or level of importance here, suffice to say that they are tools in your toolbox for helping to maintain a base level of "tedious quality", meaning style rules and general coding conventions enforced by your organization - it should never take the ultimate decision making from the developers.</p><p>That being said, let's talk about <a href="http://codenarc.sourceforge.net/">CodeNarc</a>. CodeNarc is a rule-based code quality analysis tool for Groovy-based projects. Groovy does not always play nice with other code analysis tools, so it's nice that there is one specially designed for it and <a href="http://gradle.org">Gradle</a> provides access to it out of the box.</p><p>Using the <a href="http://www.gradle.org/docs/current/dsl/org.gradle.api.plugins.quality.CodeNarc.html">Gradle CodeNarc plugin</a> is easy, apply the plugin to your build</p>
<pre><code>apply plugin: &#39;codenarc&#39;
</code></pre><p>and then do a bit of rule configuration based on the needs of your code base. </p>
<pre><code class="groovy">codenarcMain {
    ignoreFailures false
    configFile file(&#39;config/codenarc/codenarc-main.rules&#39;)

    maxPriority1Violations 0
    maxPriority2Violations 10
    maxPriority3Violations 20
}

codenarcTest {
    ignoreFailures true
    configFile file(&#39;config/codenarc/codenarc-test.rules&#39;)

    maxPriority1Violations 0
    maxPriority2Violations 10
    maxPriority3Violations 20
}
</code></pre><p>The plugin allows you to have different configurations for your main code and your test code, and I recommend using that functionality since generally you may care about slightly different things in your production code versus your test code. Also, there are JUnit-specific rules that you can ignore in your production code scan.</p><p>Notice that in my example, I have ignored failures in the test code. This is handy when you are doing a lot of active development and don't really want to fail your build every time your test code quality drops slightly. You can also set the thresholds for allowed violations of the three priority levels - when the counts exceed one of the given thresholds, the build will fail, unless it's ignored. You will always get a report for both main and test code in your build reports directory, even if there are no violations. The threshold numbers are something you will need to determine based on your code base, your team and your needs.</p><p>The <code>.rules</code> files are really Groovy DSL files, but the extension is unimportant so I like to keep them out of the Groovy namespace. The CodeNarc web site has a sample "<a href="http://codenarc.sourceforge.net/StarterRuleSet-AllRulesByCategory.groovy.txt">kitchen sink</a>" rule set to get things started - though it has a few rules that cause errors, you can comment those out or remove them from the file. Basically the file is a list of all the active rules, so removing one disables it. You can also configure some of them. LineLength is one I like to change:</p>
<pre><code>LineLength { length = 150 }
</code></pre><p>This will keep the rule active, but will allow line lengths of 150 rather than the default 120 characters. You will need to check the JavaDocs for configurable rule properties; for the most part, they seem to be on or off. </p><p>Running the analysis is simple, the <code>check</code> task may be run by itself, or it will be run along with the <code>build</code> task.</p>
<pre><code>gradle check
</code></pre><p>The reports (main and test) will be available in the <code>build/reports/codenarc</code> directory as two html files. They are not the prettiest reports, but they are functional.</p><p>If you are starting to use CodeNarc on an existing project, you may want to take a phased approach to applying and customizing rules so that you are not instantly bogged down with rule violations - do a few passes with the trimmed down rule set, fix what you can fix quickly and configure or disable the others and set your thresholds to a sensible level then make a goal to drop the numbers with each sprint or release so that progress is made.</p></p>
  	
		<a href="blog/2014/hello-again-slick2d.html"><h1>Hello Again Slick2D</h1></a>
		<p><em>11 October 2014</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/java.html'>java</a>, <a href='/tags/groovy.html'>groovy</a></p>
		<p><p>I am finally getting back around to working on my little game programming project and I realized that somewhere along the<br/>way, my project stopped working. I am using the <a href="http://slick.ninjacave.com/">Slick2D</a> library, which seems to have little<br/>in the way of formal release or distribution so it didn't surprise me. I think I had something hacked together making it<br/>work last time. I decided to try and put some more concrete and repeatable steps around basic setup, at least for how I use it - I'm no<br/>game programmer. </p><p>I'm using Groovy as my development language and Gradle for building. In the interest of time and clarity, I am going to use a<br/>dump-and-describe approach here; there are only two files, so it should not be a big deal.</p><p>The <code>build.gradle</code> file is as follows:</p>
<pre><code class="groovy">group = &#39;com.stehno.demo&#39;
version = &#39;0.1&#39;

buildscript {
    repositories {
        jcenter()

        maven {
            url &#39;http://dl.bintray.com/cjstehno/public/&#39;
        }
    }

    dependencies {
        classpath &#39;com.stehno:gradle-natives:0.2&#39;
    }
}

apply plugin:&#39;groovy&#39;
apply plugin:&#39;application&#39;
apply plugin:&#39;com.stehno.natives&#39;

compileJava {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

mainClassName = &#39;helloslick.HelloSlick&#39;

repositories {
    jcenter()
}

dependencies {
    compile &#39;org.codehaus.groovy:groovy-all:2.3.6&#39;

    compile &#39;org.slick2d:slick2d-core:1.0.1&#39;
}

test {
    systemProperty &#39;java.library.path&#39;, file(&#39;build/natives/windows&#39;)
}

run {
    systemProperty &#39;java.library.path&#39;, file(&#39;build/natives/windows&#39;)
}

natives {
    jars = [
        &#39;lwjgl-platform-2.9.1-natives-windows.jar&#39;,
        &#39;jinput-platform-2.0.5-natives-windows.jar&#39;
    ]
    platforms = &#39;windows&#39;
}

task wrapper(type: Wrapper) {
    gradleVersion = &#39;2.1&#39;
}
</code></pre><p>The first point of note, is that I am using my <a href="http://cjstehno.github.io/gradle-natives/">Gradle Natives plugin</a>, not as<br/>a self-promotion, but since this is the reason I wrote it. This plugin takes care of extracting all the little native<br/>libraries and putting them in your build so that they are easily accessible by your code. The configuration is found near<br/>the bottom of the file, in the <code>natives</code> block - we want to extract the native libraries from the lwjgl and jinput libraries<br/>for this project and in my case, I only care about the Windows versions (leave off <code>platforms</code> to get all platforms).</p><p>There was one interesting development during my time away from this project, a 3rd-party jar version of Slick2D has been pushed to maven central, which makes it a lot easier - I think I had to build it myself and fiddle with pushing it to my local maven repo or something. Now it's just another remote library (hopefully it works as expected - I have not played with it yet).</p><p>The last point of interest here is the use of the <code>application</code> plugin. This plugin provides an easy way to run your game<br/>while specifying the <code>java.library.path</code> which is the painful part of running applications with native libraries. With the<br/><code>application</code> plugin and the <code>run</code> configuration in place, you can run the game from Gradle - admittedly not ideal, but this<br/>is just development; I actually have a configuration set for the IzPack installer that I will write about later.</p><p>Now, we need some code to run, and the Slick2D wiki provides a simple Hello world sample that I have tweaked a bit for my<br/>use - mostly just cosmetic changes:</p>
<pre><code class="groovy">package helloslick

import groovy.util.logging.Log
import org.newdawn.slick.*

import java.util.logging.Level

@Log
class HelloSlick extends BasicGame {

    HelloSlick(String gamename){
        super(gamename)
    }

    @Override
    public void init(GameContainer gc) throws SlickException {}

    @Override
    public void update(GameContainer gc, int i) throws SlickException {}

    @Override
    public void render(GameContainer gc, Graphics g) throws SlickException {
        g.drawString &#39;Hello Slick!&#39;, 50, 50
    }

    public static void main(String[] args){
        try {
            AppGameContainer appgc = new AppGameContainer(new HelloSlick(&#39;Simple Slick Game&#39;))
            appgc.setDisplayMode(640, 480, false)
            appgc.start()

        } catch (SlickException ex) {
            log.log(Level.SEVERE, null, ex)
        }
    }
}
</code></pre><p>This just opens a game window and writes "Hello Slick!" in it, but if you have that working, you should be ready for playtime<br/>with Slick2D.</p><p>Once you have the project setup (<code>build.gradle</code> in the root, and <code>HelloSlick.groovy</code> in <code>/src/main/groovy/helloslick</code>), you<br/>are ready to go. Run the following to run the project.</p><p><code>gradle unpackNatives run</code></p><p>And if all is well, you will see the game window and message.</p><p>Like I said, this is mostly just for getting my development environment up and running as a sanity check, but maybe it is useful to others.</p>
<blockquote><p>Yes, the explicit <code>unpackNatives</code> calls are annoying, it's something I am working on.</p>
</blockquote></p>
  	
		<a href="blog/2014/spring-boot-embedded-server-api.html"><h1>Spring Boot Embedded Server API</h1></a>
		<p><em>15 September 2014</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/spring.html'>spring</a>, <a href='/tags/groovy.html'>groovy</a>, <a href='/tags/java.html'>java</a>, <a href='/tags/gradle.html'>gradle</a></p>
		<p><p>I have been investigating <a href="http://projects.spring.io/spring-boot/">Spring-Boot</a> for both work and personal projects and while it seems very all-encompassing and useful, I have found that its "opinionated" approach to development was a bit too aggressive for the project conversion I was doing at work; however, I did come to the realization that you don't have to use Spring-Boot as your projects core - you can use it and most of its features in your own project, just like any other java library.</p><p>The project I was working on had a customized embedded Jetty solution with a lot of tightly-coupled Jetty-specific configuration code with configuration being pulled from a Spring Application context. I did a little digging around in the Spring-Boot documentation and found that their API provides direct access to the embedded server abstraction used by a Boot project. On top of that, it's actually a very sane and friendly API to use. During my exploration and experimentation I was able to build up a simple demo application, which seemed like good fodder for a blog post - we're not going to solve any problems here, just a little playtime with the Spring-Boot embedded server API.</p><p>To start off, we need a project to work with; I called mine "spring-shoe" (not big enough for the whole boot, right?). I used Java 8, Groovy 2.3.2 and Gradle 2.0, but slightly older versions should also work fine - the build file looks like:</p>
<pre><code class="groovy">apply plugin: &#39;groovy&#39;

compileJava {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

compileGroovy {
    groovyOptions.optimizationOptions.indy = false
}

repositories {
    jcenter()
}

dependencies {
    compile &#39;org.codehaus.groovy:groovy-all:2.3.2&#39;

    compile &#39;javax.servlet:javax.servlet-api:3.0.1&#39;
    compile &#39;org.eclipse.jetty:jetty-webapp:8.1.15.v20140411&#39;

    compile &#39;org.springframework.boot:spring-boot:1.1.5.RELEASE&#39;
    compile &#39;org.springframework:spring-web:4.0.6.RELEASE&#39;
    compile &#39;org.springframework:spring-webmvc:4.0.6.RELEASE&#39;
}
</code></pre><p>Notice, that I am using the spring-boot library, not the Gradle plugin or "starter" dependencies - this also means that you have to bring in other libraries yourself (e.g. the web and webmvc libraries above).</p><p>Next, we need an application starter, which just instantiates a specialized Application context, the <code>AnnotationConfigEmbeddedWebApplicationContext</code>:</p>
<pre><code class="groovy">package shoe

import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext
import org.springframework.boot.context.embedded.EmbeddedWebApplicationContext

class Shoe {
    static void main( args ){
        EmbeddedWebApplicationContext context = new AnnotationConfigEmbeddedWebApplicationContext(&#39;shoe.config&#39;)
        println &quot;Started context on ${new Date(context.startupDate)}&quot;
    }
}
</code></pre><p>Where the package <code>shoe.config</code> is where my configuration class lives - the package will be auto-scanned. When this class' main method is run, it instantiates the context and just prints out the context start date. Internally this context will search for the embedded server configuration beans as well as any servlets and filters to be loaded on the server - but I am jumping ahead; we need a configuration class:</p>
<pre><code class="groovy">package shoe.config

import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory
import org.springframework.boot.context.embedded.jetty.JettyEmbeddedServletContainerFactory
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.EnableWebMvc

@Configuration
@EnableWebMvc
class ShoeConfig {

    @Bean EmbeddedServletContainerFactory embeddedServletContainerFactory(){
        new JettyEmbeddedServletContainerFactory( 10101 )
    }
}
</code></pre><p>As you can see, it's just a simple Java-based configuration class. The <code>EmbeddedServletContainerFactory</code> class is the crucial part here. The context loader searches for a configured bean of that type and then loads it to create the embedded servlet container - a Jetty container in this case, running on port 10101.</p><p>Now, if you run <code>Shoe.main()</code> you will see some logging similar to what is shown below:</p>
<pre><code>...
INFO: Jetty started on port: 10101
Started context on Thu Sep 04 18:59:24 CDT 2014
</code></pre><p>You have a running server, though its pretty boring since you have nothing useful configured. Let's start make it say hello using a simple servlet named <code>HelloServlet</code>:</p>
<pre><code class="groovy">package shoe.servlet

import javax.servlet.ServletException
import javax.servlet.http.HttpServlet
import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse

class HelloServlet extends HttpServlet {

    @Override
    protected void doGet( HttpServletRequest req, HttpServletResponse resp ) throws ServletException, IOException{
        resp.writer.withPrintWriter { w-&gt;
            w.println &quot;Hello, ${req.getParameter(&#39;name&#39;)}&quot;
        }
    }
}
</code></pre><p>It's just a simple <code>HttpServlet</code> extension that says "hello" with the input value from the "name" parameter. Nothing really special here. We could have just as easily used an extension of Spring's <code>HttpServletBean</code> here instead. Moving back to the <code>ShoeConfig</code> class, the modifications are minimal, you just create the servlet and register it as a bean.</p>
<pre><code class="groovy">@Bean HttpServlet helloServlet(){
    new HelloServlet()
}
</code></pre><p>Now fire the server up again, and browse to <a href="http://localhost:10101/helloServlet?name=Chris">http://localhost:10101/helloServlet?name=Chris</a> and you will get a response of:</p>
<pre><code>Hello, Chris
</code></pre><p>Actually, any path will resolve to that servlet since it's the only one configured. I will come back to configuration of multiple servlets and how to specify the url-mappings in a little bit, but let's take the next step and setup a <code>Filter</code> implementation. Let's create a Filter that counts requests as they come in and then passes the current count along with the continuing request.</p>
<pre><code class="groovy">package shoe.servlet

import org.springframework.web.filter.GenericFilterBean

import javax.servlet.FilterChain
import javax.servlet.ServletException
import javax.servlet.ServletRequest
import javax.servlet.ServletResponse
import java.util.concurrent.atomic.AtomicInteger

class RequestCountFilter extends GenericFilterBean {

    private final AtomicInteger count = new AtomicInteger(0)

    @Override
    void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException{
        request.setAttribute(&#39;request-count&#39;, count.incrementAndGet())

        chain.doFilter( request, response )
    }
}
</code></pre><p>In this case, I am using the Spring helper, <code>GenericFilterBean</code> simply so I only have one method to implement, rather than three. I could have used a simple <code>Filter</code> implementation.</p><p>In order to make use of this new count information, we can tweak the <code>HelloServlet</code> so that it prints out the current count with the response - just change the <code>println</code> statement to:</p>
<pre><code class="groovy">w.println &quot;&lt;${req.getAttribute(&#39;request-count&#39;)}&gt; Hello, ${req.getParameter(&#39;name&#39;)}&quot;
</code></pre><p>Lastly for this case, we need to register the filter as a bean in the <code>ShoeConfig</code> class:</p>
<pre><code class="groovy">@Bean Filter countingFilter(){
    new RequestCountFilter()
}
</code></pre><p>Now, run the application again and hit the hello servlet a few times and you will see something like:</p>
<pre><code>&lt;10&gt; Hello, Chris
</code></pre><p>The default url-mapping for the filter is "/*" (all requests). While, this may be useful for some quick demo cases, it would be much more useful to be able to define the servlet and filter configuration similar to what you would do in the web container configuration - well, that's where the <code>RegistrationBeans</code> come into play.</p><p>Revisiting the servlet and filter configuration in <code>ShoeConfig</code> we can now provide a more detailed configuration with the help of the <code>ServletRegistrationBean</code> and the <code>FilterRegistrationBean</code> classes, as follows:</p>
<pre><code class="groovy">@Bean ServletRegistrationBean helloServlet(){
    new ServletRegistrationBean(
        urlMappings:[ &#39;/hello&#39; ],
        servlet: new HelloServlet()
    )
}

@Bean FilterRegistrationBean countingFilter(){
    new FilterRegistrationBean(
        urlPatterns:[ &#39;/*&#39; ],
        filter: new RequestCountFilter()
    )
}
</code></pre><p>We still leave the filter mapped to all requests, but you now have access to any of the filter mapping configuration parameters. For instance, we can add a simple init-param to the <code>RequestCountingFilter</code>, such as:</p>
<pre><code class="groovy">int startValue = 0

private AtomicInteger count

@Override
protected void initFilterBean() throws ServletException {
    count = new AtomicInteger(startValue)
}
</code></pre><p>This will allow the starting value of the count to be specified as a filter init-parameter, which can be easily configured in the filter configuration:</p>
<pre><code class="groovy">@Bean FilterRegistrationBean countingFilter(){
    new FilterRegistrationBean(
        urlPatterns:[ &#39;/*&#39; ],
        filter: new RequestCountFilter(),
        initParameters:[ &#39;startValue&#39;: &#39;1000&#39; ]
    )
}
</code></pre><p>Nice and simple. Now, when you run the application again and browse to <a href="http://localhost:10101/helloServlet?name=Chris">http://localhost:10101/helloServlet?name=Chris</a> you get a 404 error. Why? Well, now you have specified a url-mapping for the servlet, try <a href="http://localhost:10101/hello?name=Chris">http://localhost:10101/hello?name=Chris</a> and you will see the expected result, something like:</p>
<pre><code>&lt;1004&gt; Hello, Chris
</code></pre><p>You can also register <code>ServletContextListeners</code> in a similar manner. Let's create a simple one:</p>
<pre><code class="groovy">package shoe.servlet

import javax.servlet.ServletContextEvent
import javax.servlet.ServletContextListener

class LoggingListener implements ServletContextListener {

    @Override
    void contextInitialized(ServletContextEvent sce) {
        println &quot;Initialized: $sce&quot;
    }

    @Override
    void contextDestroyed(ServletContextEvent sce) {
        println &quot;Destroyed: $sce&quot;
    }
}
</code></pre><p>And then configure it in <code>ShoeConfig</code>:</p>
<pre><code class="groovy">@Bean ServletListenerRegistrationBean listener(){
    new ServletListenerRegistrationBean(
        listener: new LoggingListener()
    )
}
</code></pre><p>Then, when you run the application, you will get a message in the server output like:</p>
<pre><code>Initialized: javax.servlet.ServletContextEvent[source=ServletContext@o.s.b.c.e.j.JettyEmbeddedWebAppContext{/,null}]
</code></pre><p>Now, let's do something a bit more interesting - let's setup a Spring-MVC configuration inside our embedded server.</p><p>The first thing you need for a minimal Spring-MVC configuration is a <code>DispatcherServlet</code> which, at its heart, is just an <code>HttpServlet</code> so we can just configure it as a bean in <code>ShoeConfig</code>:</p>
<pre><code class="groovy">@Bean HttpServlet dispatcherServlet(){
    new DispatcherServlet()
}
</code></pre><p>Then, we need a controller to make sure this configuration works - how about a simple controller that responds with the current time; we will also dump the request count to show that the filter is still in play. The controller looks like:</p>
<pre><code class="groovy">package shoe.controller

import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

import javax.servlet.http.HttpServletRequest

@RestController
class TimeController {

    @RequestMapping(&#39;/time&#39;)
    String time( HttpServletRequest request ){
        &quot;&lt;${request.getAttribute(&#39;request-count&#39;)}&gt; Current-time: ${new Date()}&quot;
    }
}
</code></pre><p>Lastly for this example, we need to load the controller into the configuration; just add a <code>@ComponentScan</code> annotation to the <code>ShoeConfig</code> as:</p>
<pre><code class="groovy">@ComponentScan(basePackages=[&#39;shoe.controller&#39;])
</code></pre><p>Fire up the server and hit the <a href="http://localhost:10101/time">http://localhost:10101/time</a> controller and you see something similar to:</p>
<pre><code>&lt;1002&gt; Current-time: Fri Sep 05 07:02:36 CDT 2014
</code></pre><p>Now you have the ability to do any of your Spring-MVC work with this configuration, while the standard filter and servlet still work as before.</p>
<blockquote><p>As a best-practice, I would suggest keeping this server configuration code separate from other configuration code for anything more than a trivial application (i.e. you wouldn't do your security and database config in this same file).</p>
</blockquote><p>For my last discussion point, I want to point out that the embedded server configuration also allows you to do additional customization to the actual server instance during startup. To handle this additional configuration, Spring provides the <code>JettyServerCustomizer</code> interface. You simply implement this interface and add it to your sever configuration factory bean. Let's do a little customization:</p>
<pre><code class="groovy">class ShoeCustomizer implements JettyServerCustomizer {

    @Override
    void customize( Server server ){
        SelectChannelConnector myConn = server.getConnectors().find { Connector conn -&gt;
            conn.port == 10101
        }

        myConn.maxIdleTime = 1000 * 60 * 60
        myConn.soLingerTime = -1

        server.setSendDateHeader(true)
    }
}
</code></pre><p>Basically just a tweak of the main connector and also telling the server to send an additional response header with the date value. This needs to be wired into the factory configuration, so that bean definition becomes:</p>
<pre><code class="groovy">@Bean EmbeddedServletContainerFactory embeddedServletContainerFactory(){
    def factory = new JettyEmbeddedServletContainerFactory( 10101 )
    factory.addServerCustomizers( new ShoeCustomizer() )
    return factory
}
</code></pre><p>Now when you start the server and hit the time controller you will see an additional header in the response:</p>
<pre><code>Date:Fri, 05 Sep 2014 12:15:27 GMT
</code></pre><p>As you can see from this long discussion, the Spring-Boot embedded server API is quite useful all on its own. It's nice to see that Spring has exposed this functionality as part of its public API rather than hiding it under the covers somewhere.</p>
<blockquote><p>The code I used for this article can be found in the main repository for this project, under the <a href="https://github.com/cjstehno/coffeaelectronica/tree/master/spring-shoe">spring-shoe</a> directory.</p>
</blockquote></p>
  	
		<a href="blog/2014/nodetypes-rabbit-hole.html"><h1>NodeTypes - Deeper Down the Rabbit Hole</h1></a>
		<p><em>23 August 2014</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/java.html'>java</a>, <a href='/tags/groovy.html'>groovy</a></p>
		<p><p>In my last post about <a href="http://jackrabbit.apache.org">Jackrabbit</a>, "<a href="Wabbit-Season-with-Jackrabbit">Wabbit Season with Jackrabbit</a>", I fleshed out the old Jackrabbit tutorial and expanded it a bit to ingest some image file content. I touched on the subject of node types briefly, but did little with them. In this post, I am going to delve a bit deeper into using node types and creating your own.</p><p>In the older versions of Jackrabbit, they a text-based format for configuring your own node types. I is not well documented, and I was not at all sad to see that it is no longer used since Jackrabbit 2.x. There may be another approach to loading node types, but I found the programmatic approach interesting.</p><p>For this post, you will want to refer to the code presented in the other post, "<a href="Wabbit-Season-with-Jackrabbit">Wabbit Season with Jackrabbit</a>" as a starting point (especially the last version of the code, which the code here will be based on).</p><p>For this example, we are going to expand the previous example to include image metadata in the stored node properties. I was originally under the impression that Jackrabbit would automatically extract the metadata on ingestion of the data, but it appears that this is only the case for text-based data when doing indexing. This is not a big roadblock, though, since <a href="http://tika.apache.org">Apache Tika</a> is included with Jackrabbit, although a slightly older version than what I wanted to use. You can add the following to your <code>build.gradle</code> file to update the version:</p>
<pre><code class="groovy">compile &#39;org.apache.tika:tika-parsers:1.5&#39;
</code></pre><p>Tika provides metadata extractors for a wide range of file formats, one of which is JPEG images, which is what we are playing with here.</p><p>First, we need to extract the metadata from the image file. I did this just after the main method's file reference statement:</p>
<pre><code class="groovy">def metadata = extractMetadata( file )
</code></pre><p>The code for the <code>extractMetadata(File)</code> method is as follows:</p>
<pre><code class="groovy">private static Map&lt;String,String&gt; extractMetadata( File imageFile ){
    def meta = new Metadata()
    def extractor = new ImageMetadataExtractor( meta )

    log.info &#39;Extracting metadata from {}&#39;, imageFile

    extractor.parseJpeg(imageFile)

    def props = [:]
    meta.names().sort().each { name-&gt;
        props[name] = meta.get(name)
        log.info &quot; : &lt;image-meta&gt; $name : ${meta.get(name)}&quot;
    }

    return props
}
</code></pre><p>It's just a simple straight-forward use of the Tika <code>ImageMetadataExtractor</code>, which pulls out all the data and stores it into a Map for use later.</p><p>Then, after we create the main file node, we want to apply the metadata properties to it:</p>
<pre><code class="groovy">applyMetadata( fileNode, metadata )
</code></pre><p>The <code>applyMetadata(Node,Map)</code> method applies the metadata from the map as properties on the node. The code is as shown below:</p>
<pre><code class="groovy">private static void applyMetadata( Node node, Map&lt;String,String&gt; metadata ){
    node.addMixin(&#39;pp:photo&#39;)
    node.setProperty(&#39;pp:photo-width&#39;, metadata[&#39;Image Width&#39;].split(&#39; &#39;)[0] as long )

    log.info &#39;Applied mixin -&gt; {} :: {}&#39;, node.mixinNodeTypes.collect { it.name }.join(&#39;, &#39;), node.getProperty(&#39;pp:photo-width&#39;).string
}
</code></pre><p>For the metadata, I used the concept of "Mixin" node types. Every node has a primary node type, in this case it's an "nt:file" node, but nodes can have multiple mixin node types also applied to them so that they can have additional properties available. This works perfectly in my case, since I want a file that is a photo with extra metadata associated with it.</p><p>Also, the <code>dumpProps(Node)</code> method changed slightly to avoid errors during extraction, and to hide properties we don't care about seeing:</p>
<pre><code class="groovy">private static void dumpProps( Node node ){
    log.info &#39;Node ({}) of type ({}) with mixins ({})&#39;, node.name, node.getPrimaryNodeType().name, node.getMixinNodeTypes()

    def iter = node.properties
    while( iter.hasNext() ){
        def prop = iter.nextProperty()
        if( prop.type != PropertyType.BINARY ){
            if( prop.name != &#39;jcr:mixinTypes&#39; ){
                log.info &#39; - {} : {}&#39;, prop.name, prop.value.string
            }
        } else {
            log.info &#39; - {} : &lt;binary-data&gt;&#39;, prop.name
        }
    }
}
</code></pre><p>If you run the code at this point, you will get an error about the node type not being defined, so we need to define the new node type. In the current version of Jackrabbit, they defer node type creation to the standard JCR 2.0 approach, which is pretty clean. The code is shown below:</p>
<pre><code class="groovy">private static void registerNodeTypes(Session session ) throws Exception {
    if( !session.namespacePrefixes.contains(&#39;pp&#39;) ){
        session.workspace.namespaceRegistry.registerNamespace(&#39;pp&#39;, &#39;http://stehno.com/pp&#39;)
    }

    NodeTypeManager manager = session.getWorkspace().getNodeTypeManager()

    if( !manager.hasNodeType(&#39;pp:photo&#39;) ){
        NodeTypeTemplate nodeTypeTemplate = manager.createNodeTypeTemplate()
        nodeTypeTemplate.name = &#39;pp:photo&#39;
        nodeTypeTemplate.mixin = true

        PropertyDefinitionTemplate propTemplate = manager.createPropertyDefinitionTemplate()
        propTemplate.name = &#39;pp:photo-width&#39;
        propTemplate.requiredType = PropertyType.LONG
        propTemplate.multiple = false
        propTemplate.mandatory = true

        nodeTypeTemplate.propertyDefinitionTemplates &lt;&lt; propTemplate

        manager.registerNodeType( nodeTypeTemplate, false )
    }
}
</code></pre><p>Which is called just after logging in and getting a reference to a repository session. Basically, you use the <code>NodeTypeManager</code> to create a <code>NodeTypeTemplate</code> which you can use to specify the configuration settings of your new node type. There is a similar construct for node type properties, the <code>PropertyDefinitionTemplate</code>. Once you have your configuration done, you register the node type and you are ready to go.</p><p>When run, this code generates output similar to:</p>
<pre><code>2014-08-23 16:43:02 Rabbits [INFO] User (admin) logged into repository (Jackrabbit)
...
2014-08-23 16:43:02 Rabbits [INFO]  : &lt;image-meta&gt; Image Width : 2448 pixels
...
2014-08-23 16:43:02 Rabbits [INFO] Applied mixin -&gt; pp:photo :: 2448
2014-08-23 16:43:02 Rabbits [INFO] Stored image file data into node (2014-08-19 20.49.40.jpg)...
2014-08-23 16:43:02 Rabbits [INFO] Node (2014-08-19 20.49.40.jpg) of type (nt:file) with mixins ([org.apache.jackrabbit.core.nodetype.NodeTypeImpl@5b3bb1f7])
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:createdBy : admin
2014-08-23 16:43:02 Rabbits [INFO]  - pp:photo-width : 2448
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:primaryType : nt:file
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:created : 2014-08-23T16:43:02.531-05:00
2014-08-23 16:43:02 Rabbits [INFO] Node (jcr:content) of type (nt:resource) with mixins ([])
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:lastModified : 2014-08-19T20:49:44.000-05:00
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:data : &lt;binary-data&gt;
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:lastModifiedBy : admin
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:uuid : a699fbd6-4493-4dc7-9f7a-b87b84cb1ef9
2014-08-23 16:43:02 Rabbits [INFO]  - jcr:primaryType : nt:resource
</code></pre><p>(I omitted a bunch of the metadata output lines to clean up the output)</p><p>You can see that the new node type data is populated from the metadata and the mixin is properly applied.</p><p>Call me crazy, but this approach seems a lot cleaner than the old text-based approach. There are some rules around node types and ensuring that they are not created if they already exist, though this only seems to be a problem in certain use cases - need to investigate that a bit more, but be aware of it.</p><p>Now, you can stop here and create new node types all day long, but let's take this experiment a little farther down the rabbit hole. The programmatic approach to node type configuration seems to lend itself nicely to a Groovy-based DSL approach, something like:</p>
<pre><code class="groovy">private static void registerNodeTypes( Session session ) throws Exception {
    definitions( session.workspace ){
        namespace &#39;pp&#39;, &#39;http://stehno.com/pp&#39;

        nodeType {
            name &#39;pp:photo&#39;
            mixin true

            propertyDefinition {
                name &#39;pp:photo-width&#39;
                requiredType PropertyType.LONG
                multiple false
                mandatory true
            }

            propertyDefinition {
                name &#39;pp:photo-height&#39;
                requiredType PropertyType.LONG
                multiple false
                mandatory true
            }
        }
    }
}
</code></pre><p>Seems like a nice clean way to create new node types and their properties with little fuss and muss. So, using a little Groovy DSL closure delegation we can do this without too much pain:</p>
<pre><code class="groovy">class NodeTypeDefiner {

    private final NodeTypeManager manager
    private final Workspace workspace

    private NodeTypeDefiner( final Workspace workspace ){
        this.workspace = workspace
        this.manager = workspace.nodeTypeManager
    }

    void namespace( String name, String uri ){
        if( !workspace.namespaceRegistry.prefixes.contains(name) ){
            workspace.namespaceRegistry .registerNamespace(name, uri)
        }
    }

    static void definitions( final Workspace workspace, Closure closure ){
        NodeTypeDefiner definer = new NodeTypeDefiner( workspace )
        closure.delegate = definer
        closure.resolveStrategy = Closure.DELEGATE_ONLY
        closure()
    }

    void nodeType( Closure closure ){
        def nodeTypeTemplate = new DelegatingNodeTypeTemplate( manager )

        closure.delegate = nodeTypeTemplate
        closure.resolveStrategy = Closure.DELEGATE_ONLY
        closure()

        manager.registerNodeType( nodeTypeTemplate, true )
    }
}
</code></pre><p>The key pain point I found here was that with the nested closure structures, I needed to change the <code>resolveStrategy</code> so that you get the delegate only rather than the owner - took a little debugging to trace that one down.</p><p>The other useful point here was the "Delegating" extensions of the two "template" classes:</p>
<pre><code class="groovy">class DelegatingNodeTypeTemplate implements NodeTypeDefinition {

    @Delegate NodeTypeTemplate template
    private final NodeTypeManager manager

    DelegatingNodeTypeTemplate( final NodeTypeManager manager ){
        this.manager = manager
        this.template = manager.createNodeTypeTemplate()
    }

    void name( String name ){
        template.setName( name )
    }

    void mixin( boolean mix ){
        template.mixin = mix
    }

    void propertyDefinition( Closure closure ){
        def propertyTemplate = new DelegatingPropertyDefinitionTemplate( manager )
        closure.delegate = propertyTemplate
        closure.resolveStrategy = Closure.DELEGATE_ONLY
        closure()
        propertyDefinitionTemplates &lt;&lt; propertyTemplate
    }
}

class DelegatingPropertyDefinitionTemplate implements PropertyDefinition {

    @Delegate PropertyDefinitionTemplate template
    private final NodeTypeManager manager

    DelegatingPropertyDefinitionTemplate( final NodeTypeManager manager ){
        this.manager = manager
        this.template = manager.createPropertyDefinitionTemplate()
    }

    void name( String name ){
        template.setName( name )
    }

    void requiredType( int propertyType ){
        template.setRequiredType( propertyType )
    }

    void multiple( boolean value ){
        template.multiple = value
    }

    void mandatory( boolean value ){
        template.mandatory = value
    }
}
</code></pre><p>They provide the helper methods to allow a nice clean DSL. Without them you have only setters, which did not work out cleanly. You just end up with some small delegate classes.</p><p>This code takes care of adding in the property definitions, registering namespaces and node types. It does not currently support all the configuration properties; however, that would be simple to add - there are not very many available.</p><p>As you can see from the DSL example code, you can now add new node types in a very simple manner. This kind of thing is why I love Groovy so much.</p>
<blockquote><p>If there is any interest in this DSL code, I will be using it in one of my own projects, so I could extract it into a library for more public use - let me know if you are interested.</p>
</blockquote></p>
  	
		<a href="blog/2014/wabbit-season-with-jackrabbit.html"><h1>Wabbit Season with Jackrabbit</h1></a>
		<p><em>23 August 2014</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/java.html'>java</a>, <a href='/tags/groovy.html'>groovy</a></p>
		<p><p>I have been playing with <a href="http://jackrabbit.apache.org">Apache Jackrabbit</a> today, while doing some research for one of my personal projects, and while it seems to have matured a bit since the last time I looked into it, the documentation has stagnated. Granted, it still works as a jump-start better than nothing at all, but it really does not reflect the current state of the API. I present here a more modern take on the "<a href="http://jackrabbit.apache.org/first-hops.html">First Hops</a>" document based on what I did for my research - I am using Gradle, Groovy, and generally more modern versions of the libraries involved. Maybe this can help others, or myself at a later date.</p><h2>Getting Started</h2><p>The quickest and easiest way to get started is using an embedded <code>TransientRepository</code>. Create a project directory and create a <code>build.groovy</code> Gradle build file similar to the following:</p>
<pre><code class="groovy">apply plugin: &#39;groovy&#39;

repositories {
    jcenter()
}

dependencies {
    compile &#39;org.codehaus.groovy:groovy-all:2.3.6&#39;

    compile &#39;javax.jcr:jcr:2.0&#39;
    compile &#39;org.apache.jackrabbit:jackrabbit-core:2.8.0&#39;
    compile &#39;org.slf4j:slf4j-log4j12:1.7.7&#39;
}
</code></pre><p>This will give you the required dependencies and a nice playground project to work with.</p><h2>Logging in to Jackrabbit</h2><p>In the <code>src/main/groovy</code> directory of the project, create a file called <code>Rabbits.groovy</code> with the following code:</p>
<pre><code class="groovy">import groovy.util.logging.Slf4j
import org.apache.jackrabbit.core.TransientRepository

import javax.jcr.Repository
import javax.jcr.Session

@Slf4j
class Rabbits {

    static void main(args) throws Exception {
        Repository repository = new TransientRepository(
            new File(&#39;./build/repository&#39;)
        )

        Session session = repository.login()
        try {
            String user = session.getUserID()
            String name = repository.getDescriptor(Repository.REP_NAME_DESC)

            log.info &#39;Logged in as {} to a {} repository.&#39;, user, name

        } finally {
            session.logout()
        }
    }
}
</code></pre><p>The important part here is the <code>TransientRepository</code> code, which allows you to use/reuse a repository for testing. I found that specifying a repository directory in my build directory was useful since by default it will put a bunch of files and directories in the root of your project when you run the project - it's just a little cleaner when you can run <code>gradle clean</code> to wipe out your development repository when needed. The downside of specifying the directory seems to be that your repository is not completely transient. I was not clear whether or not this was always the case or just when I set the directory, hence the need to wipe it out sometimes.</p><p>The rest of the code is pretty clear, it just does a login to the repository and writes out some information. When run, you should get something like the following:</p>
<pre><code class="2014-08-23 15:23:09 Rabbits [INFO] Logged in as anonymous to a Jackrabbit repository.```"><br/>The `finally` block is used to always logout of the repository, though this seems a bit dubious because it seemed quite easy to lock the repository in a bad state when errors caused application failure - this will require some additional investigation.

Lastly, to round out the first version of the project, create a `log4j.properties` file in `src/main/resources` so that your logger has some configuration. I used:

</code></pre><p>log4j.rootCategory=INFO, Cons</p><h1>log4j.logger.com.something=ERROR</h1><p>log4j.logger.org.apache.jackrabbit=WARN</p><p>log4j.appender.Cons = org.apache.log4j.ConsoleAppender<br/>log4j.appender.Cons.layout = org.apache.log4j.PatternLayout<br/>log4j.appender.Cons.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss} %c{1} [%p] %m%n<br/>```</p>
<blockquote><p>If you want to see more about what Jackrabbit is doing, set the logging level for <code>log4j.logger.org.apache.jackrabbit</code> to <code>INFO</code> - it gets a little verbose, so I turned it down to WARN.</p>
</blockquote><h2>Working with Content</h2><p>When using a content repository, you probably want to do something with actual content, so let's start off with a simple case of some nodes with simple text content. The <code>main</code> method of the <code>Rabbits</code> class now becomes:</p>
<pre><code class="groovy">Repository repository = new TransientRepository(
    new File(&#39;./build/repository&#39;)
)

Session session = repository.login(
    new SimpleCredentials(&#39;admin&#39;,&#39;admin&#39;.toCharArray())
)

try {
    String username = session.userID
    String name = repository.getDescriptor(Repository.REP_NAME_DESC)
    log.info &#39;User ({}) logged into repository ({})&#39;, username, name

    Node root = session.rootNode

    // Store content
    Node hello = root.addNode(&#39;hello&#39;)
    Node world = hello.addNode(&#39;world&#39;)
    world.setProperty(&#39;message&#39;, &#39;Hello, World!&#39;)
    session.save()

    // Retrieve content
    Node node = root.getNode(&#39;hello/world&#39;)
    log.info &#39;Found node ({}) with property: {}&#39;, node.path, node.getProperty(&#39;message&#39;).string

    // Remove content
    root.getNode(&#39;hello&#39;).remove()
    log.info &#39;Removed node.&#39;

    session.save()

} finally {
    session.logout()
}
</code></pre><p>Notice, that the login code now contains credentials so that we can login with a writable session rather than the read-only default session (previous example).</p><p>First, we need to store some content in the repository. Since Jackrabbit is a hierarchical data store, you need to get a reference to the root node, and then add a child node to it with some content:</p>
<pre><code class="groovy">Node root = session.rootNode

// Store content
Node hello = root.addNode(&#39;hello&#39;)
Node world = hello.addNode(&#39;world&#39;)
world.setProperty(&#39;message&#39;, &#39;Hello, World!&#39;)
session.save()
</code></pre><p>We create a node named "hello", the add a child named "world" to that node, and give the child node a "message" property. Notice that we save the session to persist the changes to the underlying data store.</p><p>Next, we want to read the data back out:</p>
<pre><code class="groovy">Node node = root.getNode(&#39;hello/world&#39;)
log.info &#39;Found node ({}) with property: {}&#39;, node.path, node.getProperty(&#39;message&#39;).string
</code></pre><p>You just get the node by it's relative path, in this case from the root, and then retrieve its data.</p><p>Lastly, for this example, we want to remove the nodes we just added:</p>
<pre><code class="groovy">root.getNode(&#39;hello&#39;).remove()
session.save()
log.info &#39;Removed node.&#39;
</code></pre><p>Removing the "hello" node removes it and it's children (i.e. the "world" node). We then save the session to commit the node removal.</p><p>When you run this version of the code, you should see something like this:</p>
<pre><code>2014-08-23 15:45:18 Rabbits [INFO] User (admin) logged into repository (Jackrabbit)
2014-08-23 15:45:18 Rabbits [INFO] Found node (/hello/world) with property: Hello, World!
2014-08-23 15:45:18 Rabbits [INFO] Removed node.
</code></pre><h2>Working with Binary Content</h2><p>This is where my tour diverts from the original wiki document, which goes on to cover XML data imports. I was more interested in loading binary content, especially image files. To accomplish this, we need to consider how the data is stored in JCR. I found a very helpful article "<a href="https://docs.jboss.org/author/display/MODE/Storing+files+and+folders?_sscc=t">Storing Files and Folders</a>" from the ModeShape documentation (another JCR implementation) - since it's standard JCR, it is still relevant with Jackrabbit.</p><p>Basically you need a node for the file and it's metadata, which has a child node for the actual file content. The article has some nice explanations and diagrams, so if you want more than code and quick discussion I recommend you head over there and take a look at it. For my purpose, I am just going to ingest a single image file and then read out the data to ensure that it was actually stored. The code for the <code>try/finally</code> block of our example becomes:</p>
<pre><code class="groovy">String username = session.userID
String name = repository.getDescriptor(Repository.REP_NAME_DESC)
log.info &#39;User ({}) logged into repository ({})&#39;, username, name

Node root = session.rootNode

// Assume that we have a file that exists and can be read ...
File file = IMAGE_FILE

// Determine the last-modified by value of the file (if important) ...
Calendar lastModified = Calendar.instance
lastModified.setTimeInMillis(file.lastModified())

// Create an &#39;nt:file&#39; node at the supplied path ...
Node fileNode = root.addNode(file.name, &#39;nt:file&#39;)

// Upload the file to that node ...
Node contentNode = fileNode.addNode(&#39;jcr:content&#39;, &#39;nt:resource&#39;)
Binary binary = session.valueFactory.createBinary(file.newInputStream())
contentNode.setProperty(&#39;jcr:data&#39;, binary)
contentNode.setProperty(&#39;jcr:lastModified&#39;,lastModified)

// Save the session (and auto-created the properties) ...
session.save()

log.info &#39;Stored image file data into node ({})...&#39;, file.name

// now get the image node data back out

def node = root.getNode(file.name)
dumpProps node

dumpProps node.getNode(&#39;jcr:content&#39;)
</code></pre><p>Where <code>IMAGE_FILE</code> is a <code>File</code> object pointing to a JPEG image file.</p><p>The first thing we do is create the file node:</p>
<pre><code class="groovy">Node fileNode = root.addNode(file.name, &#39;nt:file&#39;)
</code></pre><p>Notice, it's of type <code>nt:file</code> to designate that it's a file node - you will want to brush up on NodeTypes in the Jackrabbit or JCR documentation if you don't already have a basic understanding; I won't do much more than use them in these examples. For the name of the node, we just use the file name.</p><p>Second, we create the file content node as a child of the file node:</p>
<pre><code class="groovy">Node contentNode = fileNode.addNode(&#39;jcr:content&#39;, &#39;nt:resource&#39;)
Binary binary = session.valueFactory.createBinary(file.newInputStream())
contentNode.setProperty(&#39;jcr:data&#39;, binary)
contentNode.setProperty(&#39;jcr:lastModified&#39;,lastModified)

// Save the session (and auto-created the properties) ...
session.save()
</code></pre><p>Notice that the child node is named "jcr:content" and is of type "nt:resource" and that it has a property named "jcr:data" containing the binary data content for the file. Of course, the session is saved to persist the changes.</p><p>Once we have the file data stored, we want to pull it back out to see that we stored everything as intended:</p>
<pre><code class="groovy">def node = root.getNode(file.name)
dumpProps node

dumpProps node.getNode(&#39;jcr:content&#39;)
</code></pre><p>The <code>dumpProps</code> method just iterates the properties of a given node and writes them to the log file:</p>
<pre><code class="groovy">private static void dumpProps( Node node ){
    log.info &#39;Node: ({})&#39;, node.name

    def iter = node.properties
    while( iter.hasNext() ){
        def prop = iter.nextProperty()
        if( prop.type != PropertyType.BINARY ){
            log.info &#39; - {} : {}&#39;, prop.name, prop.value.string
        } else {
            log.info &#39; - {} : &lt;binary-data&gt;&#39;, prop.name
        }
    }
}
</code></pre><p>When you run this version of the code, you will have output similar to:</p>
<pre><code>2014-08-23 16:09:18 Rabbits [INFO] User (admin) logged into repository (Jackrabbit)
2014-08-23 16:09:18 Rabbits [INFO] Stored image file data into node (2014-08-19 20.49.40.jpg)...
2014-08-23 16:09:18 Rabbits [INFO] Node: (2014-08-19 20.49.40.jpg)
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:createdBy : admin
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:created : 2014-08-23T15:59:26.155-05:00
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:primaryType : nt:file
2014-08-23 16:09:18 Rabbits [INFO] Node: (jcr:content)
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:lastModified : 2014-08-19T20:49:44.000-05:00
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:data : &lt;binary-data&gt;
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:lastModifiedBy : admin
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:uuid : cbdefd4a-ec2f-42d2-b58a-a39942766723
2014-08-23 16:09:18 Rabbits [INFO]  - jcr:primaryType : nt:resource
</code></pre><h2>Conclusion</h2><p>Jackrabbit seems to still have some development effort behind it, and it's still a lot easier to setup and use when compared with something like ModeShape, which seems to be the only other viable JCR implementation which is not specifically geared to a target use case.</p><p>The documentation is lacking, but with some previous experience and a little experimentation, it was not too painful getting things to work.</p></p>
  	
		<a href="blog/2014/simple-configuration-dsl-using-groovy.html"><h1>Simple Configuration DSL using Groovy</h1></a>
		<p><em>19 July 2014</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/java.html'>java</a>, <a href='/tags/groovy.html'>groovy</a></p>
		<p><p>Recently at work we were talking about being able to process large configuration files from legacy applications where the config file had a fairly simple text-based format. One of my co-workers mentioned that you could probably just run the configuration file like a Groovy script and just handle the <code>missingMethod()</code> calls and use them to populate a configuration object. This sounded like an interesting little task to play with so I threw together a basic implementation - and it's actually easier than I thought.</p><p>To start out with, we need a configuration holder class, which we'll just call <code>Configuration</code>:</p>
<pre><code class="groovy">class Configuration {
    String hostName
    String protocol
    int port
    Headers headers
}
</code></pre><p>Say we are collecting configuration information for some sort of HTTP request util or something, it's a contrived example, but shows the concept nicely. The <code>Headers</code> class is a simple delegated builder in itself, and looks like:</p>
<pre><code class="groovy">@ToString(includeNames=true)
class Headers {
    Map&lt;String,Object&gt; values = [:]

    static Headers headers( Closure closure ){
        Headers h = new Headers()
        closure.delegate = h
        closure()
        return h
    }
    
    void header( String name, value ){
        values[name] = value
    }
}
</code></pre><p>I won't explain much about the <code>Headers</code> class, other than it takes a closure and delegates the method calls of it onto a <code>Headers</code> instance to populate it. For our purposes it just makes a nice simple way to show closure usage in the example.</p><p>Now, we need a configuration file to load. It's just a simple text file:</p>
<pre><code class="text">hostname &#39;localhost&#39;
protocol = &#39;https&#39;
port 2468

headers {
    header &#39;Content-type&#39;,&#39;text/html&#39;
    header &#39;Content-length&#39;,10101
}
</code></pre><p>The script-based configuration is similar to the delegated builder, in that the method calls of the "script" (text configuration file) will be delegated to an instance of the <code>Configuration</code> class. For that to work, we could override the <code>missingMethod()</code> method and handle each desired operation, or if we have a good idea of the configuration (as we do in our case), we could just add the missing methods, as follows:</p>
<pre><code class="groovy">@ToString(includeNames=true)
class Configuration {

    String hostName
    int port
    Headers headers
   
    void hostname( final String name ){
        this.hostName = name
    }

    void port( final int port ){
        this.port = port
    }
    
    void headers( final Closure closure ){
        this.headers = Headers.headers( closure )
    }
}
</code></pre><p>Basically, they are just setters in our case; however, you could do whatever conversion or validation you need, they're just method calls. Also, notice that the <code>protocol</code> property in the configuration file is actually setting the property directly with an equals <code>=</code> rather than using a method call - this is also valid, though personally I like the way it looks without all the equals signs.</p><p>The final part needed to make this work, is the Groovy magic. We need to load the text as a script in a <code>GroovyShell</code>, parse it and run it. The whole code for the <code>Configuration</code> object is shown below:</p>
<pre><code class="groovy">@ToString(includeNames=true)
class Configuration {

    String hostName
    String protocol
    int port
    Headers headers
   
    void hostname( final String name ){
        this.hostName = name
    }

    void port( final int port ){
        this.port = port
    }
    
    void headers( final Closure closure ){
        this.headers = Headers.headers( closure )
    }

    static Configuration configure( final File file ){
        def script = new GroovyShell(
            new CompilerConfiguration(
                scriptBaseClass:DelegatingScript.class.name 
            )
        ).parse(file)

        def configuration = new Configuration()
        script.setDelegate( configuration )
        script.run()

        return configuration
    }
}
</code></pre><p>The important parts are the use of the <code>DelegatingScript</code> as the <code>scriptBaseClass</code> and then setting the <code>Configuration</code> instance as the delegate for the script. Now if you run the following:</p>
<pre><code>def conf = Configuration.configure( new File(&#39;conf.txt&#39;) )
println conf
</code></pre><p>You get something like the following output: </p>
<pre><code>Configuration(protocol:https, hostName:localhost, port:2468, headers:Headers(values:[Content-type:text/html, Content-length:10101]))
</code></pre>
<blockquote><p>Notice, that in the example we didn't define a method for <code>protocol</code>, which means that the only way you can set it in the configuration is as a property; however, we could use the property format to set the value of the other fields, such as <code>port</code> since there is a setter method available along with the helper method (options are nice).</p>
</blockquote><p>Groovy makes simple DSLs, well... simple.</p></p>
  	
		<a href="blog/2014/going-native-with-gradle.html"><h1>Going Native with Gradle</h1></a>
		<p><em>16 March 2014</em> ~ <a href='/tags/blog.html'>blog</a>, <a href='/tags/java.html'>java</a>, <a href='/tags/groovy.html'>groovy</a>, <a href='/tags/gradle.html'>gradle</a></p>
		<p><p>With my recent foray into Java game programming, I found the support for managing the native sub-dependencies of jar files to be a bit lacking in Gradle. I did find a few blog posts about the general ways of adding it to your build; however, I did not find any specific plugin or built-in support. Since I am planning on doing a handful of simple games as a tutorial for game programming it made sense for me to pull out my native library handling functionality into a Gradle plugin... and thus the <a href="https://github.com/cjstehno/gradle-natives">Gradle Natives Plugin</a> was born.</p><p>First, we need a project to play with. I found a simple <a href="http://philphilphil.wordpress.com/2009/05/28/helloworld-using-lwjgl/">LWJGL Hello World</a> application that works nicely for our starting point. So, create the standard Gradle project structure with the following files:</p>
<pre><code class="java">// hello/src/main/java/hello/HelloWorld.java
package hello;

import org.lwjgl.LWJGLException;
import org.lwjgl.opengl.Display;
 
public class HelloWorld {
    public static void main (String args[]){
        try {
            Display.setTitle(&quot;Hello World&quot;);
            Display.create();
			
			while(!Display.isCloseRequested()){
				Thread.sleep(100);      
			}
		
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
			Display.destroy();
		}
    }
}
</code></pre><p>with a standard Gradle build file as a starting point: </p>
<pre><code class="groovy">// hello/build.gradle

apply plugin:&#39;java&#39;

repositories {
	jcenter()
}

dependencies {
	compile &#39;org.lwjgl.lwjgl:lwjgl:2.9.1&#39;
}
</code></pre><p>At this point, the project will build, but will not run without jumping through some extra hoops. Let's do some of that hoop-jumping in Gradle with the <code>application</code> plugin. Add the following to the <code>build.gradle</code> file:</p>
<pre><code class="groovy">apply plugin:&#39;application&#39;

mainClassName = &#39;hello.HelloWorld&#39;
</code></pre><p>This adds the <code>run</code> task to the build which will run the <code>HelloWorld</code> main class; however, this still won't work since it does not know how to deal with the LWJGL native libraries. That's where the <code>natives</code> plugin comes in. At this time there is no official release of the plugin on Bintray (coming soon), so you will need to clone the repo and build the plugin, then install it into your local maven repo:</p>
<pre><code>git clone git@github.com:cjstehno/gradle-natives.git

cd gradle-natives

gradle build install
</code></pre><p>Once that is done, you will need to add the natives plugin to your build:</p>
<pre><code class="groovy">buildscript {
    repositories {
        mavenLocal()
    }

    dependencies {
        classpath &#39;gradle-natives:gradle-natives:0.1&#39;
    }
}

apply plugin:&#39;natives&#39;
</code></pre><p>And then you will need to apply the custom configuration for your specific native libraries. You will need to add an entry in the jars list for each dependency jar containing native libraries. These are the jars that will be searched on the classpath for native libraries by platform.</p>
<pre><code class="groovy">natives {
	jars = [
		&#39;lwjgl-platform-2.9.1-natives-windows&#39;, 
		&#39;lwjgl-platform-2.9.1-natives-osx&#39;, 
		&#39;lwjgl-platform-2.9.1-natives-linux&#39;
	]
}
</code></pre><p>This will allow the associated native libraries to be unpacked into the build directory with:</p><p><code>gradle unpackNatives</code></p><p>Which will copy the libraries into a directory for each platform under <code>build/natives/PLATFORM</code>. Then we need one more step to allow it to be run. The <code>java.library.path</code> needs to be set before the run:</p>
<pre><code class="groovy">run {
    systemProperty &#39;java.library.path&#39;, file( &#39;build/natives/windows&#39; )
}
</code></pre><p>Then you can run the application using:</p><p><code>gradle run</code></p><p>Granted, there are still issues to be resolved with the plugin. Currently, it is a little picky about when it is run. If you have tests that use the native libraries you will need to build without tests and then run the tests:</p>
<pre><code>gradle clean build unpackNatives -x test

gradle test
</code></pre><p>Lastly, you can also specify the platforms whose library files are to be copied over using the <code>platforms</code> configuration property, for example:</p>
<pre><code class="groovy">natives {
	jars = [
		&#39;lwjgl-platform-2.9.1-natives-windows&#39;, 
		&#39;lwjgl-platform-2.9.1-natives-osx&#39;, 
		&#39;lwjgl-platform-2.9.1-natives-linux&#39;
	]
	platforms = &#39;windows&#39;
}
</code></pre><p>Will only copy the windows libraries into the build.</p><p>Feel free to create an issue for any bugs you find or features you would like to see. Also, I am open to bug fixes and pull requests from others.</p></p>
  	
	
	<hr />
	
	<p>Older posts are available in the <a href="/archive.html">archive</a>.</p>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2015 <a href="https://plus.google.com/+ChristopherStehno">Christopher J. Stehno</a> | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.3.2</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-27165855-1', 'auto');
      ga('send', 'pageview');
    </script>
    
  </body>
</html>